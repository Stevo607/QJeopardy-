    <script type="module">
        // --- Constants ---
        const STORAGE_KEY_GAME = 'quality_jeopardy_game_progress_v11_' + location.pathname; // Version for FJ answer hide
        const STORAGE_KEY_SCORES = 'quality_jeopardy_high_scores_v1';
        const PLAYER_COLORS = ['#4caf50', '#2196f3', '#ff9800', '#e91e63', '#9c27b0', '#00bcd4', '#f44336', '#ffc107'];
        const MIN_WAGER = 5;
        const DAILY_DOUBLE_MAX_WAGER_BASE = 1000;

        // --- Game Data ---
        const gameData = {
             categories: [ { name: 'Food Safety', clues: [200, 400, 600, 800, 1000] }, { name: 'GMPs', clues: [200, 400, 600, 800, 1000] }, { name: 'FSMA', clues: [200, 400, 600, 800, 1000] }, { name: 'Allergens', clues: [200, 400, 600, 800, 1000] }, { name: 'HACCP', clues: [200, 400, 600, 800, 1000] }, { name: 'Chocolate', clues: [200, 400, 600, 800, 1000] } ]
        };
        const questionBank = { // Using placeholder answers for context
            'Food Safety': [
                'The temperature danger zone for potentially hazardous foods is generally recognized as being between 41°F and what upper temperature? (A: 135°F)',
                'This common practice involves cooling cooked food rapidly through the temperature danger zone. (A: Two-stage cooling)',
                'What is the minimum internal cooking temperature required for poultry? (A: 165°F)',
                'Cross-contamination can be prevented by using separate cutting boards for raw meat and this type of food. (A: Ready-to-eat foods)',
                'The "Big 9" refers to the major food ________ recognized by the US FDA that must be declared on labels. (A: Allergens)',
            ],
            'GMPs':        [
                 'What does GMP stand for? (A: Good Manufacturing Practices)',
                'This critical hygiene step is required before starting work, after each break, and whenever hands become contaminated (A: What is proper handwashing?)',
                'This basic inventory practice ensures older ingredients are used first to prevent spoilage and maintain product quality. (A: What is FIFO—First-In, First-Out?)',
                'All employees must remove these items, with the exception of a plain wedding band, before entering food handling areas. (A: What is jewelry?)',
                'These food safety hazards, including glass, metal, allergens, cleaning agents, bacteria, and mold, must be controlled at all stages of production, processing, and storage. (A: What are physical, chemical, and biological hazards?)',
          ],
            'FSMA':        [
                'FSMA, signed into law in 2011, stands for the Food Safety ____________ Act. (A: Modernization)',
                'This key rule under FSMA requires food facilities to develop and implement a written Food Safety Plan based on hazard analysis. (A: Preventive Controls for Human Food Rule)',
                'A PCQI is a Preventive Controls _________ Individual, required to oversee the Food Safety Plan. (A: Qualified)',
                'FSMA shifted the focus of food safety from responding to contamination to ___________ it. (A: Preventing)',
                'This FSMA rule focuses on ensuring the safety of fresh fruits and vegetables during growing, harvesting, packing, and holding. (A: Produce Safety Rule)',
            ],
            'Allergens':   [
                'Besides Tree Nuts, Peanuts, Milk, Eggs, Soy, Wheat, Fish, and Crustacean Shellfish, what is the 9th major US food allergen added in 2023? (A: Sesame)',
                'FALCPA requires allergen declarations to be in clear, plain language, often using the word "Contains" followed by the allergen name(s). What does FALCPA stand for? (A: Food Allergen Labeling and Consumer Protection Act)',
                'An effective Allergen Control Plan includes preventing this, the unintentional incorporation of an allergen into a food. (A: Cross-contact)',
                'Cleaning procedures must be validated to ensure they effectively remove allergen ________ from shared equipment. (A: Residues)',
                '"May contain..." or "Processed in a facility that also handles..." are examples of what type of non-mandatory labeling? (A: Precautionary Allergen Labeling / PAL / Advisory Statements)',
            ],
            'HACCP':       [
                'What does HACCP stand for? (A: Hazard Analysis and Critical Control Point)',
                'How many principles are there in a HACCP system? (A: Seven)',
                'Principle 1 involves conducting a ________ analysis to identify potential biological, chemical, or physical risks. (A: Hazard)',
                'A point in the process where control can be applied and is essential to prevent or eliminate a food safety hazard is called a ______. (A: Critical Control Point / CCP)',
                'Establishing critical limits, monitoring procedures, corrective actions, verification, and record-keeping are the remaining principles after Hazard Analysis and determining CCPs. Which principle involves defining the maximum or minimum value a CCP must meet? (A: Establishing Critical Limits)',
            ],
            'Chocolate':   [
                'Chocolate liquor, cocoa butter, and sugar are the main ingredients in this type of chocolate. (A: Dark Chocolate)',
                'This process involves heating and cooling chocolate to specific temperatures to stabilize the cocoa butter crystals, giving it a smooth texture and sheen. (A: Tempering)',
                'Originating from the beans of the Theobroma cacao tree, chocolate production primarily occurs in regions near this imaginary line circling the Earth. (A: Equator)',
                'The "bloom" seen on old chocolate is often caused by migration of either fat or ______ to the surface. (A: Sugar)',
                'This type of chocolate contains milk solids and typically has a milder flavor than dark chocolate. (A: Milk Chocolate)',
            ]
        };
        // MODIFIED FJ Data Structure
        const finalJeopardyQuestions = [
            { category: "Food Safety Final", question: "This federal agency is primarily responsible for regulating meat, poultry, and processed egg products in the US.", answer: "USDA-FSIS" },
            { category: "GMP Final", question: "What does the acronym 'PIC' often stand for in the context of food safety management?", answer: "Person In Charge" },
            { category: "FSMA Final", question: "This FSMA rule requires domestic and foreign facilities to establish and implement a food defense plan.", answer: "Mitigation Strategies to Protect Food Against Intentional Adulteration or 'Food Defense Rule'" }
        ];
        let finalJeopardyData = null; // Will store the selected {question, answer, category} object

        // --- State Variables ---
        let players = []; let currentPlayerId = null; let gameStarted = false; let boardState = {};
        let historyStack = []; let scoreHistory = {}; let currentWager = 0; let answeredCluesCount = 0;
        let turnCounter = 0; let playerTurnIndex = 0; let activeChart = null; let activeCardElement = null;
        let rotateControlEnabled = false; // NEW: Control rotation setting

        // --- Calculated Values ---
        const numCategories = gameData.categories.length; const numCluesPerCat = gameData.categories[0]?.clues?.length ?? 0; const totalClues = numCategories * numCluesPerCat;

        // --- DOM References ---
        // (References remain the same as previous version)
        const boardElement = document.getElementById('board'); const victoryElement = document.getElementById('victory'); const musicElement = document.getElementById('bg-music'); const musicToggleElement = document.getElementById('music-toggle');
        const rotateControlToggleElement = document.getElementById('rotate-control-toggle'); // NEW DOM reference
        const addPlayerBtnElement = document.getElementById('add-player'); const startGameBtnElement = document.getElementById('start-game'); const playerNameInputElement = document.getElementById('player-name'); const playerListElement = document.getElementById('player-list'); const scorePanelElement = document.getElementById('score-panel'); const scoreDisplayElement = document.getElementById('score-display'); const manualScoreInputElement = document.getElementById('manual-score'); const applyScoreBtnElement = document.getElementById('apply-score'); const undoBtnElement = document.getElementById('undo-score'); const resetScoresBtnElement = document.getElementById('reset-all-scores'); const newGameBtnElement = document.getElementById('new-game'); const showFinalJeopardyBtnElement = document.getElementById('show-final-jeopardy'); const finalJeopardySectionElement = document.getElementById('final-jeopardy'); const finalCategoryElement = document.getElementById('final-category'); const finalQuestionElement = document.getElementById('final-question'); const revealFinalQuestionBtnElement = document.getElementById('reveal-final-question'); const submitFinalWagersBtnElement = document.getElementById('submit-final-wagers'); const judgeFinalAnswersBtnElement = document.getElementById('judge-final-answers'); const finalWagersContainerElement = document.getElementById('final-wagers'); const resultsModalElement = document.getElementById('results-modal'); const finalResultsElement = document.getElementById('final-results'); const saveHighScoresBtnElement = document.getElementById('save-high-scores'); const modalCloseElement = document.querySelector('.modal-close'); const scoreHistoryContainerElement = document.getElementById('score-history-container'); const scoreHistoryChartCanvas = document.getElementById('score-history-chart'); const chartPlaceholderText = document.getElementById('chart-placeholder-text'); const highScoresListElement = document.getElementById('high-scores-list'); const correctSound = document.getElementById('correct-sound'); const wrongSound = document.getElementById('wrong-sound'); const dailyDoubleSound = document.getElementById('daily-double-sound'); const finalJeopardySound = document.getElementById('final_jeopardy.mp3'); const stealControlsElement = document.getElementById('steal-controls'); const noOtherTakersBtnElement = document.getElementById('no-other-takers-btn'); const questionDisplayAreaElement = document.getElementById('question-display-area'); const currentQuestionTextElement = document.getElementById('current-question-text');

        // --- Utility Functions ---
        function getPlayerById(playerId) { return players.find(p => p.id === playerId); }
        function playSound(audioElement) { if (audioElement && typeof audioElement.play === 'function' && musicToggleElement?.checked) { audioElement.currentTime = 0; audioElement.play().catch(e => console.warn("Audio play failed:", audioElement.id, e.message)); } else if (!musicToggleElement?.checked && audioElement !== musicElement) {} else if (!audioElement) console.warn("Attempted to play null audio element."); }
        function launchConfetti() { const cC=100; const cCo=document.body; for (let i = 0; i < cC; i++) { const c = document.createElement('div'); c.className = 'confetti'; c.style.left = Math.random() * 100 + 'vw'; c.style.backgroundColor = PLAYER_COLORS[Math.floor(Math.random() * PLAYER_COLORS.length)]; const aD = Math.random() * 3 + 2; c.style.animationDuration = aD + 's'; c.style.animationDelay = Math.random() * 0.5 + 's'; cCo.appendChild(c); setTimeout(() => { c.remove(); }, (aD + 1) * 1000); } }

        // NEW: Function to handle speech synthesis
        function speakQuestion(text) {
            const musicToggleElement = document.getElementById('music-toggle');

            if (!('speechSynthesis' in window)) {
                console.warn('Speech synthesis not supported by this browser.');
                return;
            }

            // Use the music toggle as a proxy for enabling speech.
            if (!musicToggleElement || !musicToggleElement.checked) {
                console.log('Speech synthesis skipped (music/speech toggle is off).');
                return;
            }

            window.speechSynthesis.cancel(); // Stop any ongoing speech

            const utterance = new SpeechSynthesisUtterance(text);
            // Optional: Customize voice, rate, pitch if needed.
            // const voices = window.speechSynthesis.getVoices();
            // utterance.voice = voices.find(v => v.lang === 'en-US'); // Example: select a voice

            window.speechSynthesis.speak(utterance);
        }

        // --- Question Display ---
        function showQuestionDisplay(text) {
             if (currentQuestionTextElement && questionDisplayAreaElement) {
                  currentQuestionTextElement.textContent = text;
                  questionDisplayAreaElement.style.display = 'block';
             }
        }
        function hideQuestionDisplay() {
             if (currentQuestionTextElement && questionDisplayAreaElement) {
                  currentQuestionTextElement.textContent = ''; // Clear text
                  questionDisplayAreaElement.style.display = 'none';
             }
        }

        // Helper function to reveal the answer on the card back
        function revealCardAnswer(cardElement) {
            const cardBack = cardElement.querySelector('.card-back');
            const questionTextDisplay = cardBack?.querySelector('.question-text');
            const revealAnswerBtn = cardBack?.querySelector('.reveal-answer-btn');

            if (cardBack && questionTextDisplay && cardBack.dataset.answer) {
                questionTextDisplay.textContent = cardBack.dataset.answer; // Display the answer
            }
            if (revealAnswerBtn) {
                revealAnswerBtn.style.display = 'none'; // Hide the button
                revealAnswerBtn.onclick = null; // Clear event listener
            }
        }

        // --- Core Game Logic ---
        function updatePlayerScore(playerId, delta, isUndo = false, cardKey = null) { const player = getPlayerById(playerId); if (player) { const oldScore = player.score; player.score += delta; const newScore = player.score; console.log(`Score Update: ${player.name} ${oldScore} -> ${newScore} (Delta: ${delta}, Turn: ${turnCounter})`); if (!scoreHistory[playerId]) scoreHistory[playerId] = []; scoreHistory[playerId].push({ turn: turnCounter, score: newScore }); if (!isUndo) { historyStack.push({ action: 'score', playerId: playerId, delta: delta, turn: turnCounter, cardKey: cardKey }); updateUndoButtonState(); } updatePlayerCards(); updateScoreDisplay(); drawScoreHistoryChart(); } else { console.error("Player not found for score update:", playerId); } if (!isUndo) saveGameProgress(); }
        function nextPlayerTurnRegular() { if (players.length <= 1) return; playerTurnIndex = (playerTurnIndex + 1) % players.length; currentPlayerId = players[playerTurnIndex]?.id; turnCounter++; console.log(`Regular Turn ${turnCounter}: ${players[playerTurnIndex]?.name}'s turn (Index: ${playerTurnIndex})`); updatePlayerCards(); updateScoreDisplay(); saveGameProgress(); }
        function setActivePlayer(playerId, isHostIntervention = false) { const player = getPlayerById(playerId); if (player) { const previousPlayerId = currentPlayerId; currentPlayerId = playerId; const newIndex = players.findIndex(p => p.id === playerId); if (newIndex !== -1) playerTurnIndex = newIndex; if (isHostIntervention && previousPlayerId !== playerId) { turnCounter++; console.log(`Host Intervention (Turn ${turnCounter}): Set Active Player to ${player.name} (Index: ${playerTurnIndex})`); } else { console.log(`Set Active Player: ${player.name} (Index: ${playerTurnIndex}) (No turn count change)`); } updatePlayerCards(); updateScoreDisplay(); saveGameProgress(); } else { console.error("Attempted to set active player to non-existent ID:", playerId); } }
        function handleHostPlayerSelection(event) { const selectedPlayerCard = event.currentTarget; const selectedPlayerId = selectedPlayerCard.dataset.playerId; if (!gameStarted) return; if (finalJeopardySectionElement.style.display === 'block') { console.log("Host selection blocked: Final Jeopardy active."); return; } if (activeCardElement) { alert("Cannot change player while a question is active. Please resolve it first."); return; } if (stealControlsElement.style.display === 'flex') { console.log("Host selection blocked: Steal selection active."); return; } if (!selectedPlayerId) { console.warn("Host selection failed: No player ID on card."); return; } console.log(`Host selecting player: ${getPlayerById(selectedPlayerId)?.name}`); setActivePlayer(selectedPlayerId, true); }
        function updatePlayerCards() { if (!playerListElement) return; const isSelectionModeActive = !!document.querySelector('.card.pending-steal'); const activeCardStateKey = activeCardElement?.dataset?.stateKey; const failedPlayerIds = activeCardStateKey ? (boardState[activeCardStateKey]?.failedPlayerIds || []) : []; playerListElement.innerHTML = ''; players.forEach(player => { const card = document.createElement('div'); card.className = 'player-card'; card.dataset.playerId = player.id; const indicator = document.createElement('div'); indicator.className = 'player-indicator'; indicator.style.backgroundColor = player.color; const nameElem = document.createElement('div'); nameElem.className = 'player-name'; nameElem.textContent = player.name || 'Unnamed Player'; const scoreElem = document.createElement('div'); scoreElem.className = 'player-score'; scoreElem.textContent = `$${player.score}`; card.appendChild(indicator); card.appendChild(nameElem); card.appendChild(scoreElem); card.removeEventListener('click', handlePlayerCardClickForAnswer); card.removeEventListener('click', handleHostPlayerSelection); card.classList.remove('selectable-player', 'failed-attempt', 'host-selectable'); if (player.id === currentPlayerId && gameStarted) card.classList.add('active-player'); if (isSelectionModeActive) { if (failedPlayerIds.includes(player.id)) { card.classList.add('failed-attempt'); card.style.cursor = 'not-allowed'; } else { card.classList.add('selectable-player'); card.style.cursor = 'pointer'; card.addEventListener('click', handlePlayerCardClickForAnswer); } } else if (gameStarted && finalJeopardySectionElement.style.display !== 'block') { card.classList.add('host-selectable'); card.style.cursor = 'pointer'; card.addEventListener('click', handleHostPlayerSelection); } else { card.style.cursor = 'default'; } playerListElement.appendChild(card); }); }
        function updateScoreDisplay() { if (!scoreDisplayElement) return; let mainText = ""; let statusText = ""; if (activeCardElement && activeCardElement.classList.contains('pending-steal')) statusText = "Select next player to answer or 'No Takers'"; if (currentPlayerId && gameStarted) { const player = getPlayerById(currentPlayerId); if(player) mainText = `Turn: ${player.name} | Score: $${player.score}`; else mainText = "Waiting for player..."; } else if (!gameStarted) mainText = "Add players and start game"; else mainText = "Game Over"; scoreDisplayElement.innerHTML = mainText + (statusText ? `<span class="status-text">${statusText}</span>` : ""); }
        function generateBoard() {
            if (!boardElement) return;
            boardElement.innerHTML = '';
            boardElement.style.gridTemplateColumns = `repeat(${numCategories}, 1fr)`;
            gameData.categories.forEach(cat => {
                const d = document.createElement('div');
                d.className = 'category';
                d.textContent = cat.name;
                boardElement.appendChild(d);
            });
            for (let r = 0; r < numCluesPerCat; r++) {
                for (let c = 0; c < numCategories; c++) {
                    const v = gameData.categories[c]?.clues[r] ?? 0;
                    const catN = gameData.categories[c]?.name ?? 'Unknown';
                    const qT = questionBank[catN]?.[r] ?? 'Question not found!';
                    const id = `card-${c}-${r}`;
                    const key = `${c}-${r}`;
                    const card = document.createElement('div');
                    card.className = 'card';
                    card.id = id;
                    card.dataset.catIndex = c;
                    card.dataset.rowIndex = r;
                    card.dataset.value = v;
                    card.dataset.stateKey = key;
                    const inner = document.createElement('div');
                    inner.className = 'card-inner';
                    const front = document.createElement('div');
                    front.className = 'card-face card-front';
                    const back = document.createElement('div');
                    back.className = 'card-face card-back';

                    // Extract the answer part for the card back
                    let cardBackContent = qT;
                    const answerMatch = qT.match(/\(A:\s*(.*?)\)$/);
                    if (answerMatch && answerMatch[1]) {
                        cardBackContent = answerMatch[1].trim();
                    }

                    // Store the answer in a data attribute
                    back.dataset.answer = cardBackContent;

                    // Initial HTML for the card back: empty text, reveal button, and judge buttons
                    // Note: The reveal-answer-btn's display will be controlled by JS
                    back.innerHTML = `
                        <div class="question-text"></div>
                        <div class="judge-buttons" style="display: none;">
                            <button class="reveal-answer-btn">Reveal Answer</button>
                            <div class="correct-wrong-buttons">
                                <button class="correct-btn">Correct</button>
                                <button class="wrong-btn">Wrong</button>
                            </div>
                        </div>
                    `;

                    inner.appendChild(front);
                    inner.appendChild(back);
                    card.appendChild(inner);
                    const state = boardState[key];
                    const isAnswered = state?.state === 'correct' || state?.state === 'wrong';
                    const isPending = state?.failedPlayerIds?.length > 0 && !state.state;
                    if (isAnswered) {
                        card.classList.add('disabled', state.state);
                        front.textContent = '';
                        front.classList.add('empty-value');
                        // If already answered, reveal the answer on the back
                        revealCardAnswer(card);
                    } else {
                        front.textContent = `$${v}`;
                        if (!isPending) card.addEventListener('click', handleCardClick);
                        if (state?.isDailyDouble) card.classList.add('daily-double-marker');
                        if (isPending) {
                            console.log(`generateBoard: Found pending card ${key}`);
                            card.classList.add('flipped', 'pending-steal');
                            const jB = card.querySelector('.judge-buttons');
                            if (jB) {
                                jB.style.display = 'flex';
                                // In pending state, answer should be revealed
                                revealCardAnswer(card);
                            }
                        }
                    }
                    boardElement.appendChild(card);
                }
            }
            boardElement.style.display = 'grid';
        }
        function enablePlayerSelectionMode(showButton = true) { if (!activeCardElement) { console.warn("Enable Steal Mode: No active card."); return; } const stateKey = activeCardElement.dataset.stateKey; if (!stateKey || !boardState[stateKey]) { console.warn("Enable Steal Mode: Invalid state."); return; } console.log("Entering steal selection mode:", stateKey); activeCardElement.classList.add('pending-steal'); updatePlayerCards(); if (showButton && stealControlsElement && noOtherTakersBtnElement) { stealControlsElement.style.display = 'flex'; noOtherTakersBtnElement.onclick = null; noOtherTakersBtnElement.onclick = handleNoOtherTakersClick; } updateScoreDisplay(); console.log("Steal selection enabled."); }
        function disablePlayerSelectionMode() { if (stealControlsElement) stealControlsElement.style.display = 'none'; if (activeCardElement) activeCardElement.classList.remove('pending-steal'); updatePlayerCards(); updateScoreDisplay(); console.log("Steal/Host selection modes disabled."); }
        function handlePlayerCardClickForAnswer(event) { const selectedPlayerCard = event.currentTarget; const selectedPlayerId = selectedPlayerCard.dataset.playerId; if (!activeCardElement || !selectedPlayerId) { console.warn("Steal Click: No active Q/ID."); return; } console.log(`Player ${getPlayerById(selectedPlayerId)?.name} selected for steal.`); setActivePlayer(selectedPlayerId, false); disablePlayerSelectionMode(); }

        function handleCardClick(event) {
            const card = event.currentTarget;
            const stateKey = card.dataset.stateKey;
            const catIndex = card.dataset.catIndex;
            const rowIndex = card.dataset.rowIndex;
            const currentState = boardState[stateKey] || {};
            const isAnyCardPending = !!document.querySelector('.card.pending-steal');

            if (isAnyCardPending) {
                alert("Please resolve the current question first.");
                return;
            }
            if (!gameStarted || !currentPlayerId) {
                console.warn("Card click ignored: Game not started/no player.");
                return;
            }
            if (card.classList.contains('flipped') || card.classList.contains('disabled')) {
                console.log("Card click ignored: Card resolved/judging.");
                return;
            }
            if (currentState.failedPlayerIds?.includes(currentPlayerId)) {
                alert(`${getPlayerById(currentPlayerId)?.name}, you already failed this question.`);
                return;
            }
            if (activeCardElement && activeCardElement !== card) {
                alert("Resolve current question first.");
                return;
            }

            console.log(`Card ${stateKey} clicked by ${getPlayerById(currentPlayerId)?.name}`);
            activeCardElement = card;
            card.classList.add('flipped');

            const value = parseInt(card.dataset.value, 10);
            const judgeButtons = card.querySelector('.judge-buttons');
            const cardBack = card.querySelector('.card-back');
            const questionTextDisplay = cardBack.querySelector('.question-text');
            const revealAnswerBtn = cardBack.querySelector('.reveal-answer-btn');

            const isDailyDouble = currentState.isDailyDouble ?? false;
            const categoryName = gameData.categories[catIndex]?.name ?? 'Unknown';
            const fullQuestionText = questionBank[categoryName]?.[rowIndex] ?? 'Question not found!';

            let displayQuestion = fullQuestionText;
            const answerStartIndex = fullQuestionText.indexOf('(A:');
            if (answerStartIndex !== -1) {
                displayQuestion = fullQuestionText.substring(0, answerStartIndex).trim();
            }

            if (!boardState[stateKey]) boardState[stateKey] = {};

            if (isDailyDouble) {
                playSound(dailyDoubleSound);
                console.log("DD!");
                let wager=NaN;
                const player=getPlayerById(currentPlayerId);
                if(!player) return;
                const maxW=Math.max(DAILY_DOUBLE_MAX_WAGER_BASE, player.score > 0 ? player.score : DAILY_DOUBLE_MAX_WAGER_BASE);
                while(isNaN(wager)||wager<MIN_WAGER||wager>maxW) {
                    const wI=prompt(`DAILY DOUBLE!\n${player.name}, wager (min $${MIN_WAGER}, max $${maxW}):`);
                    if(wI===null){wager=MIN_WAGER;break;}
                    wager=parseInt(wI,10);
                    if(isNaN(wager)||wager<MIN_WAGER||wager>maxW) alert(`Invalid wager. Please enter a number between $${MIN_WAGER} and $${maxW}.`);
                }
                currentWager=wager;
                console.log(`${player.name} wagered $${currentWager}`);
                showQuestionDisplay(displayQuestion);
                speakQuestion(displayQuestion);
                if (musicElement) {
                    musicElement.pause();
                }
            } else {
                currentWager=value;
                showQuestionDisplay(displayQuestion);
                speakQuestion(displayQuestion);
                if (musicElement) {
                    musicElement.pause();
                }
            }

            // Show judge buttons and reveal button
            if (judgeButtons) {
                judgeButtons.style.display = 'flex';

                // Set up "Reveal Answer" button
                if (revealAnswerBtn) {
                    // Check if the answer is already revealed (e.g., from a loaded pending state)
                    if (questionTextDisplay.textContent === cardBack.dataset.answer) {
                        revealAnswerBtn.style.display = 'none'; // Keep it hidden if answer is already shown
                    } else {
                        revealAnswerBtn.style.display = 'inline-block'; // Show the reveal button
                    }
                    // MODIFIED: Added call to speakQuestion here
                    revealAnswerBtn.onclick = (e) => {
                        e.stopPropagation();
                        const cardBack = card.querySelector('.card-back');
                        const answerText = cardBack?.dataset?.answer; // Get the answer text
                        if (answerText) {
                            speakQuestion(answerText); // Speak the answer
                        }
                        revealCardAnswer(card); // Then reveal it on the card
                    };
                }

                const cBtn = judgeButtons.querySelector('.correct-btn');
                const wBtn = judgeButtons.querySelector('.wrong-btn');
                cBtn.onclick = null;
                wBtn.onclick = null;
                cBtn.onclick = (e) => { e.stopPropagation(); judgeAnswer(card, true, currentWager, isDailyDouble); };
                wBtn.onclick = (e) => { e.stopPropagation(); judgeAnswer(card, false, currentWager, isDailyDouble); };
            }
            disablePlayerSelectionMode();
            saveGameProgress();
        }
        function handleNoOtherTakersClick() {
            if (!activeCardElement) { console.warn("No Takers: No active card."); return; }
            const stateKey = activeCardElement.dataset.stateKey;
            console.log("No takers for:", stateKey);
            hideQuestionDisplay();

            // Ensure the answer is revealed when no one takes it
            revealCardAnswer(activeCardElement);

            boardState[stateKey].state = 'wrong';
            answeredCluesCount++;
            console.log("Answered:", answeredCluesCount, "/", totalClues);
            activeCardElement.classList.remove('flipped', 'pending-steal');
            activeCardElement.classList.add('disabled', 'wrong');
            activeCardElement.removeEventListener('click', handleCardClick);
            const fF = activeCardElement.querySelector('.card-front');
            if (fF) { fF.textContent = ''; fF.classList.add('empty-value'); }
            const jB = activeCardElement.querySelector('.judge-buttons');
            if (jB) {
                jB.style.display = 'none';
                const c=jB.querySelector('.correct-btn'); if(c)c.onclick=null;
                const w=jB.querySelector('.wrong-btn'); if(w)w.onclick=null;
                const rA = jB.querySelector('.reveal-answer-btn'); if(rA) rA.onclick=null; // Clear reveal button handler
            }
            disablePlayerSelectionMode();
            activeCardElement = null;
            currentWager = 0;
            if (answeredCluesCount >= totalClues) {
                console.log("Board clear after 'No Takers'. Starting Final Jeopardy.");
                setupFinalJeopardy();
            } else {
                nextPlayerTurnRegular();
            }
            saveGameProgress();
        }
        function judgeAnswer(card, isCorrect, amount, isDailyDouble = false) {
            const stateKey = card?.dataset?.stateKey;
            if (!currentPlayerId || !card || !stateKey) { console.error("JudgeAnswer missing data", { currentPlayerId, card, stateKey }); return; }
            if (!boardState[stateKey]) boardState[stateKey] = {};
            const delta = isCorrect ? amount : -amount;
            const playerBeingJudgedId = currentPlayerId;
            console.log(`Judging ${getPlayerById(playerBeingJudgedId)?.name} on ${stateKey}. Correct: ${isCorrect}, Amount: ${delta}, DD: ${isDailyDouble}`);
            turnCounter++;
            updatePlayerScore(playerBeingJudgedId, delta, false, stateKey);
            playSound(isCorrect ? correctSound : wrongSound);
            hideQuestionDisplay();

            // Ensure the answer is revealed on the card back before hiding controls
            revealCardAnswer(card);

            let boardCleared = false;
            if (isCorrect) {
                console.log(`Correct. Question resolved.`);
                boardState[stateKey].state = 'correct';
                boardState[stateKey].playerId = playerBeingJudgedId;
                boardState[stateKey].failedPlayerIds = boardState[stateKey].failedPlayerIds || [];
                answeredCluesCount++;
                console.log("Answered:", answeredCluesCount, "/", totalClues);
                card.classList.remove('flipped', 'pending-steal');
                card.classList.add('disabled', 'correct');
                card.removeEventListener('click', handleCardClick);
                const fF = card.querySelector('.card-front');
                if (fF) { fF.textContent = ''; fF.classList.add('empty-value'); }
                const jB = card.querySelector('.judge-buttons');
                if (jB) {
                    jB.style.display = 'none';
                    const c=jB.querySelector('.correct-btn'); if(c)c.onclick=null;
                    const w=jB.querySelector('.wrong-btn'); if(w)w.onclick=null;
                    const rA = jB.querySelector('.reveal-answer-btn'); if(rA) rA.onclick=null; // Clear reveal button handler
                }
                disablePlayerSelectionMode();
                activeCardElement = null;
                currentWager = 0;
                boardCleared = answeredCluesCount >= totalClues;
                if (!boardCleared) {
                    // MODIFIED LOGIC: If Rotate Control is enabled OR it's a Daily Double, rotate the turn
                    if (isDailyDouble || rotateControlEnabled) {
                        nextPlayerTurnRegular();
                    } else { // Otherwise, the current player keeps control
                        setActivePlayer(playerBeingJudgedId, false);
                    }
                }
            } else {
                console.log(`Incorrect.`);
                if (!boardState[stateKey].failedPlayerIds) boardState[stateKey].failedPlayerIds = [];
                if (!boardState[stateKey].failedPlayerIds.includes(playerBeingJudgedId)) {
                    boardState[stateKey].failedPlayerIds.push(playerBeingJudgedId);
                }
                boardState[stateKey].state = null;
                const eligibleCount = players.filter(p => !boardState[stateKey].failedPlayerIds.includes(p.id)).length;
                if (isDailyDouble || eligibleCount === 0) {
                    console.log(isDailyDouble ? "DD incorrect. Resolved." : "All failed. Resolved.");
                    boardState[stateKey].state = 'wrong';
                    answeredCluesCount++;
                    console.log("Answered:", answeredCluesCount, "/", totalClues);
                    card.classList.remove('flipped', 'pending-steal');
                    card.classList.add('disabled', 'wrong');
                    card.removeEventListener('click', handleCardClick);
                    const fF = card.querySelector('.card-front');
                    if (fF) { fF.textContent = ''; fF.classList.add('empty-value'); }
                    const jB = card.querySelector('.judge-buttons');
                    if (jB) {
                        jB.style.display = 'none';
                        const c=jB.querySelector('.correct-btn'); if(c)c.onclick=null;
                        const w=jB.querySelector('.wrong-btn'); if(w)w.onclick=null;
                        const rA = jB.querySelector('.reveal-answer-btn'); if(rA) rA.onclick=null; // Clear reveal button handler
                    }
                    disablePlayerSelectionMode();
                    activeCardElement = null;
                    currentWager = 0;
                    boardCleared = answeredCluesCount >= totalClues;
                    if (!boardCleared) {
                        nextPlayerTurnRegular();
                    }
                } else {
                    console.log("Incorrect. Enable selection.");
                    enablePlayerSelectionMode();
                    // Make sure the reveal button is hidden if answer is already shown when re-enabling selection
                    const revealBtn = card.querySelector('.reveal-answer-btn');
                    const qText = card.querySelector('.card-back .question-text');
                    const cardBack = card.querySelector('.card-back');
                    if (revealBtn && qText.textContent === cardBack.dataset.answer) {
                        revealBtn.style.display = 'none';
                    } else if (revealBtn) { // If answer not yet shown, keep reveal button
                        revealBtn.style.display = 'inline-block';
                        revealAnswerBtn.onclick = (e) => { // Re-attach click handler for reveal
                            e.stopPropagation();
                            revealCardAnswer(card);
                        };
                    }
                }
            }
            if (boardCleared) {
                console.log("Board clear after judging. Starting Final Jeopardy.");
                setupFinalJeopardy();
            }
            saveGameProgress();
        }
        function determineDailyDouble() { if (totalClues === 0) return; Object.keys(boardState).forEach(key => { if (boardState[key]) boardState[key].isDailyDouble = false; }); const potentialLocations = []; for (let r = 1; r < numCluesPerCat; r++) { for (let c = 0; c < numCategories; c++) { const k = `${c}-${r}`; if (!boardState[k] || (!boardState[k].state && !boardState[k].failedPlayerIds?.length)) { potentialLocations.push(k); } } } if (potentialLocations.length > 0) { const dd1Index = Math.floor(Math.random() * potentialLocations.length); const dd1Key = potentialLocations.splice(dd1Index, 1)[0]; if (!boardState[dd1Key]) boardState[dd1Key] = {}; boardState[dd1Key].isDailyDouble = true; console.log("DD1 location:", dd1Key); if (numCategories >= 5 && numCluesPerCat >= 3 && potentialLocations.length > 0) { const dd2Index = Math.floor(Math.random() * potentialLocations.length); const dd2Key = potentialLocations[dd2Index]; if (!boardState[dd2Key]) boardState[dd2Key] = {}; boardState[dd2Key].isDailyDouble = true; console.log("DD2 location:", dd2Key); } } else console.log("Could not place Daily Double(s) - no eligible locations."); }

        // --- Game State & UI Management ---
        function saveGameProgress() {
            if (!gameStarted && players.length === 0 && !Object.keys(boardState).length) return;
            const state = {
                gameStarted,
                players: players.map(p => ({ ...p })),
                currentPlayerId,
                playerTurnIndex,
                boardState: JSON.parse(JSON.stringify(boardState)),
                historyStack: [...historyStack],
                answeredCluesCount,
                turnCounter,
                scoreHistory: JSON.parse(JSON.stringify(scoreHistory)),
                rotateControlEnabled // NEW: Save this state
            };
            try {
                localStorage.setItem(STORAGE_KEY_GAME, JSON.stringify(state));
            } catch (e) {
                console.error("Save Error:", e);
            }
        }
        function loadGameProgress() {
            const savedState = localStorage.getItem(STORAGE_KEY_GAME);
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    if (state && typeof state === 'object' && Array.isArray(state.players)) {
                        gameStarted = state.gameStarted ?? false;
                        players = state.players ?? [];
                        currentPlayerId = state.currentPlayerId ?? (players.length > 0 ? players[0].id : null);
                        playerTurnIndex = state.playerTurnIndex ?? (players.findIndex(p => p.id === currentPlayerId) ?? 0);
                        boardState = state.boardState ?? {};
                        historyStack = state.historyStack ?? [];
                        answeredCluesCount = state.answeredCluesCount ?? Object.values(boardState).filter(s => s?.state === 'correct' || s?.state === 'wrong').length;
                        turnCounter = state.turnCounter ?? 0;
                        scoreHistory = state.scoreHistory ?? {};
                        rotateControlEnabled = state.rotateControlEnabled ?? false; // NEW: Load this state
                        activeCardElement = null;
                        console.log("Game loaded.");
                        updateUIbasedOnGameState();
                        updateUndoButtonState();

                        // NEW: Set the toggle state visually after loading
                        if (rotateControlToggleElement) {
                            rotateControlToggleElement.checked = rotateControlEnabled;
                        }

                        const pendingKey = Object.keys(boardState).find(key => boardState[key]?.failedPlayerIds?.length > 0 && !boardState[key].state);
                        if (pendingKey) {
                            activeCardElement = document.getElementById(`card-${pendingKey.replace('-', '-')}`);
                            if (activeCardElement) {
                                console.log("Loaded into pending state:", pendingKey);
                                enablePlayerSelectionMode();
                            } else console.error("Could not find pending card element:", pendingKey);
                        } else disablePlayerSelectionMode();
                        return true;
                    } else {
                        console.warn("Invalid loaded state structure.");
                        localStorage.removeItem(STORAGE_KEY_GAME);
                    }
                } catch (e) {
                    console.error("Error parsing saved state:", e);
                    localStorage.removeItem(STORAGE_KEY_GAME);
                }
            }
            updateUIbasedOnGameState();
            updateUndoButtonState();
            // Ensure toggle reflects default state if no saved state
            if (rotateControlToggleElement) {
                rotateControlToggleElement.checked = rotateControlEnabled;
            }
            return false;
        }
        function updateUIbasedOnGameState() { const pSE = document.getElementById('player-setup'); if (!scorePanelElement || !boardElement || !startGameBtnElement || !resetScoresBtnElement || !newGameBtnElement || !showFinalJeopardyBtnElement || !finalJeopardySectionElement) { console.error("Required UI elements missing."); return; } hideQuestionDisplay(); if (gameStarted) { if (pSE) pSE.style.display = 'none'; scorePanelElement.style.display = 'flex'; const isFJActive = finalJeopardySectionElement.style.display === 'block'; if (!isFJActive) { generateBoard(); if (answeredCluesCount >= totalClues) { console.log("Loading game state where board is clear. Starting Final Jeopardy."); if (boardElement) boardElement.style.display = 'none'; setupFinalJeopardy(); return; } else { if(victoryElement) victoryElement.style.display = 'none'; showFinalJeopardyBtnElement.disabled = true; const needsDDDetermination = !Object.values(boardState).some(s => s?.isDailyDouble); if (needsDDDetermination && answeredCluesCount < totalClues) { console.log("Determining Daily Double(s) on load as none were found."); determineDailyDouble(); saveGameProgress(); generateBoard(); } } } else { if(boardElement) boardElement.style.display = 'none'; showFinalJeopardyBtnElement.disabled = true; } updatePlayerCards(); updateScoreDisplay(); startGameBtnElement.disabled = true; resetScoresBtnElement.disabled = false; newGameBtnElement.disabled = false; } else { if (pSE) pSE.style.display = 'flex'; scorePanelElement.style.display = 'none'; boardElement.style.display = 'none'; updatePlayerCards(); updateScoreDisplay(); startGameBtnElement.disabled = players.length === 0; resetScoresBtnElement.disabled = true; if (undoBtnElement) undoBtnElement.disabled = true; showFinalJeopardyBtnElement.disabled = true; finalJeopardySectionElement.style.display = 'none'; if(victoryElement) victoryElement.style.display = 'none'; if(musicElement) musicElement.pause(); disablePlayerSelectionMode(); } drawScoreHistoryChart(); }
        function setupFinalJeopardy() { // MODIFIED - Uses separate Q/A
             if (finalJeopardySectionElement.style.display === 'block') { console.log("setupFinalJeopardy called but FJ already visible. Aborting."); return; } if (finalJeopardyQuestions.length === 0) { alert("No Final Jeopardy questions available!"); return; } const eligiblePlayers = players.filter(p => p.score > 0); if (eligiblePlayers.length === 0) { alert("No players have a positive score eligible for Final Jeopardy!"); showFinalResults(); return; } finalJeopardyData = finalJeopardyQuestions[Math.floor(Math.random() * finalJeopardyQuestions.length)]; if (!finalCategoryElement || !finalQuestionElement || !revealFinalQuestionBtnElement || !submitFinalWagersBtnElement || !judgeFinalAnswersBtnElement || !finalWagersContainerElement || !finalJeopardySectionElement ) { console.error("Final Jeopardy UI elements missing."); return; } console.log("Setting up Final Jeopardy..."); hideQuestionDisplay(); disablePlayerSelectionMode(); activeCardElement = null; finalCategoryElement.textContent = `Category: ${finalJeopardyData.category}`; finalQuestionElement.textContent = finalJeopardyData.question; // <<< Display only question
             finalQuestionElement.style.display = 'none'; revealFinalQuestionBtnElement.style.display = 'inline-block'; submitFinalWagersBtnElement.style.display = 'none'; judgeFinalAnswersBtnElement.style.display = 'none'; finalWagersContainerElement.innerHTML = ''; eligiblePlayers.forEach(p => { const r = document.createElement('div'); r.className = 'wager-row'; const l = document.createElement('label'); l.htmlFor = `wager-${p.id}`; l.textContent = `${p.name} ($${p.score}):`; const i = document.createElement('input'); i.type = 'number'; i.id = `wager-${p.id}`; i.dataset.playerId = p.id; i.min = 0; i.max = p.score; i.placeholder = 'Enter wager'; i.required = true; r.appendChild(l); r.appendChild(i); finalWagersContainerElement.appendChild(r); }); if(boardElement) boardElement.style.display = 'none'; if(scorePanelElement) scorePanelElement.style.display = 'none'; if(victoryElement) victoryElement.style.display = 'none'; finalJeopardySectionElement.style.display = 'block'; if(showFinalJeopardyBtnElement) showFinalJeopardyBtnElement.disabled = true; playSound(finalJeopardySound); launchConfetti(); saveGameProgress();
        }

        // --- High Scores & Tabs ---
        function renderHighScores() { if (!highScoresListElement) return; try { const scores = JSON.parse(localStorage.getItem(STORAGE_KEY_SCORES) || '[]'); const sortedScores = scores.sort((a, b) => b.score - a.score).slice(0, 10); if (sortedScores.length === 0) highScoresListElement.innerHTML = '<li>No high scores recorded yet.</li>'; else highScoresListElement.innerHTML = sortedScores.map((s, i) => `<li><span>${i + 1}. ${s.name} (${new Date(s.date || Date.now()).toLocaleDateString()})</span><span>$${s.score}</span></li>`).join(''); } catch (e) { console.error("Error loading/rendering high scores:", e); highScoresListElement.innerHTML = '<li>Error loading scores.</li>'; } }
        function saveScoresToHighScores() { const scoresToSave = players.map(p => ({ name: p.name, score: p.score, date: Date.now() })); if (scoresToSave.length === 0) return; try { const existingScores = JSON.parse(localStorage.getItem(STORAGE_KEY_SCORES) || '[]'); const updatedScores = [...existingScores, ...scoresToSave]; localStorage.setItem(STORAGE_KEY_SCORES, JSON.stringify(updatedScores)); renderHighScores(); alert("Current game scores saved to High Scores!"); if (resultsModalElement) resultsModalElement.classList.remove('show'); const highScoresTabButton = document.querySelector('.tab-button[data-tab="high-scores-tab"]'); if(highScoresTabButton) highScoresTabButton.click(); } catch (e) { console.error("Error saving scores to high scores:", e); alert("Failed to save scores."); } }
        function setupTabs() { const tabButtons = document.querySelectorAll('.tab-button'); const tabContents = document.querySelectorAll('.tab-content'); tabButtons.forEach(button => { button.addEventListener('click', () => { const targetTabId = button.dataset.tab; if (!targetTabId) return; tabButtons.forEach(btn => btn.classList.remove('active')); tabContents.forEach(content => content.classList.remove('active')); button.classList.add('active'); const activeContent = document.getElementById(targetTabId); if (activeContent) { activeContent.classList.add('active'); if (targetTabId === 'score-history-tab') drawScoreHistoryChart(); else if (targetTabId === 'high-scores-tab') renderHighScores(); } else console.warn("Tab content not found for ID:", targetTabId); }); }); const initialActiveButton = document.querySelector('.tab-button.active'); if (initialActiveButton) { const initialTabId = initialActiveButton.dataset.tab; const initialContent = document.getElementById(initialTabId); if(initialContent) initialContent.classList.add('active'); if (initialTabId === 'score-history-tab') drawScoreHistoryChart(); else if (initialTabId === 'high-scores-tab') renderHighScores(); } else if (tabButtons.length > 0) { tabButtons[0].click(); } }
        function drawScoreHistoryChart() { if (!scoreHistoryChartCanvas || !chartPlaceholderText) return; const ctx = scoreHistoryChartCanvas.getContext('2d'); if (!ctx) return; if (activeChart) { activeChart.destroy(); activeChart = null; } const datasets = players.filter(p => scoreHistory[p.id] && scoreHistory[p.id].length > 0).map(p => { const history = scoreHistory[p.id] || []; const filteredHistory = [...history].sort((a, b) => a.turn - b.turn); if (filteredHistory.length === 0 || filteredHistory[0].turn !== 0) { filteredHistory.unshift({ turn: 0, score: 0 }); } const uniqueTurnHistory = []; const turnsSeen = new Set(); for (let i = filteredHistory.length - 1; i >= 0; i--) { const entry = filteredHistory[i]; if (!turnsSeen.has(entry.turn)) { uniqueTurnHistory.unshift(entry); turnsSeen.add(entry.turn); } } return { label: p.name, data: uniqueTurnHistory.map(e => ({ x: e.turn, y: e.score })), borderColor: p.color, backgroundColor: p.color + '30', fill: false, tension: 0.1 }; }); if (datasets.length > 0) { chartPlaceholderText.style.display = 'none'; scoreHistoryChartCanvas.style.display = 'block'; activeChart = new Chart(ctx, { type: 'line', data: { datasets }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'linear', title: { display: true, text: 'Action Turn Number' }, beginAtZero: true, ticks: { stepSize: 1, precision: 0 } }, y: { title: { display: true, text: 'Score ($)' }, beginAtZero: false } }, plugins: { title: { display: true, text: 'Score Progression Over Turns'}, tooltip: { mode: 'index', intersect: false } }, interaction: { mode: 'nearest', axis: 'x', intersect: false } } }); } else { chartPlaceholderText.style.display = 'block'; scoreHistoryChartCanvas.style.display = 'none'; } }
        function updateUndoButtonState() { if (undoBtnElement) undoBtnElement.disabled = historyStack.length === 0; }
        function showFinalResults() { if (!finalResultsElement || !resultsModalElement) return; const sortedPlayers = [...players].sort((a, b) => b.score - a.score); finalResultsElement.innerHTML = sortedPlayers.map(p => `<div>${p.name}: $${p.score}</div>`).join(''); resultsModalElement.classList.add('show'); }

        // --- Event Listeners Setup ---
        function setupEventListeners() {
            console.log("Setting up event listeners...");
            if(addPlayerBtnElement) {
                console.log("Add player button found, attaching listener.");
                addPlayerBtnElement.addEventListener('click', () => { console.log("Add Player button clicked."); if (!playerNameInputElement) { console.error("Player name input not found!"); return; } const name = playerNameInputElement.value.trim(); if (!name) { alert("Please enter a player name."); return; } if (players.length >= PLAYER_COLORS.length) { alert("Maximum number of players reached."); return; } const id = Date.now().toString(36) + Math.random().toString(36).substring(2); players.push({ id, name, score: 0, color: PLAYER_COLORS[players.length % PLAYER_COLORS.length] }); playerNameInputElement.value = ''; updatePlayerCards(); if(startGameBtnElement) startGameBtnElement.disabled = players.length === 0; playerNameInputElement.focus(); console.log("Player added:", name); saveGameProgress(); });
            } else { console.error("Add player button element not found!"); }
            if(startGameBtnElement) startGameBtnElement.addEventListener('click', () => { if (players.length === 0) { alert("Please add at least one player to start."); return; } gameStarted = true; playerTurnIndex = 0; currentPlayerId = players[playerTurnIndex]?.id; answeredCluesCount = 0; boardState = {}; historyStack = []; scoreHistory = {}; players.forEach(p => { p.score = 0; scoreHistory[p.id] = [{ turn: 0, score: 0 }]; }); turnCounter = 0; determineDailyDouble(); updateUIbasedOnGameState(); updateUndoButtonState(); if (musicToggleElement?.checked && musicElement) { musicElement.currentTime = 0; playSound(musicElement); } saveGameProgress(); });
            if(applyScoreBtnElement) applyScoreBtnElement.addEventListener('click', () => { if (!currentPlayerId || !manualScoreInputElement) return; const targetScore = parseInt(manualScoreInputElement.value, 10); if (isNaN(targetScore)) { alert("Please enter a valid number for the score."); return; } const player = getPlayerById(currentPlayerId); if (player) { const delta = targetScore - player.score; turnCounter++; updatePlayerScore(currentPlayerId, delta, false, 'manual_update'); manualScoreInputElement.value = ''; } });
            if(undoBtnElement) undoBtnElement.addEventListener('click', () => { const lastAction = historyStack.pop(); updateUndoButtonState(); if (!lastAction) return; console.log("Attempting Undo:", lastAction); hideQuestionDisplay(); if (lastAction.action === 'score') { const player = getPlayerById(lastAction.playerId); if (player) { const originalScore = player.score - lastAction.delta; player.score = originalScore; if (scoreHistory[lastAction.playerId]) { scoreHistory[lastAction.playerId] = scoreHistory[lastAction.playerId].filter(e => e.turn < lastAction.turn || (e.turn === lastAction.turn && e.score === originalScore)); } console.log(`Undo Score: ${player.name} reverted to ${player.score}`); } else { console.warn("Undo failed: Player not found", lastAction.playerId); historyStack.push(lastAction); updateUndoButtonState(); return; } if (lastAction.cardKey && lastAction.cardKey !== 'manual_update' && lastAction.cardKey !== 'final_jeopardy') { const cardEl = document.querySelector(`.card[data-state-key="${lastAction.cardKey}"]`); const cardState = boardState[lastAction.cardKey]; if (cardState && cardEl) { const wasCorrect = cardState.state === 'correct' && cardState.playerId === lastAction.playerId; const wasWrongFinal = cardState.state === 'wrong'; const wasFailedAttempt = lastAction.delta < 0 && cardState.failedPlayerIds?.includes(lastAction.playerId); console.log(`Undo Card State Check: Key=${lastAction.cardKey}, Correct=${wasCorrect}, WrongFinal=${wasWrongFinal}, FailedAttempt=${wasFailedAttempt}`); if (wasCorrect || wasWrongFinal) { answeredCluesCount--; console.log("Undo: Decremented answered count to", answeredCluesCount); } cardState.state = null; cardState.playerId = null; if (wasFailedAttempt && cardState.failedPlayerIds) { const fIdx = cardState.failedPlayerIds.indexOf(lastAction.playerId); if (fIdx > -1) { cardState.failedPlayerIds.splice(fIdx, 1); console.log(`Undo: Removed ${player?.name} from failed list for ${lastAction.cardKey}`); } } cardEl.classList.remove('disabled', 'correct', 'wrong', 'pending-steal', 'flipped');
                        const fF = cardEl.querySelector('.card-front');
                        if (fF) { fF.textContent = `$${cardEl.dataset.value}`; fF.classList.remove('empty-value'); }
                        const bF = cardEl.querySelector('.card-back');
                        const jB = bF?.querySelector('.judge-buttons');
                        if(jB) {
                            jB.style.display = 'none'; // Initially hide all buttons
                            const c=jB.querySelector('.correct-btn'); if(c)c.onclick=null;
                            const w=jB.querySelector('.wrong-btn'); if(w)w.onclick=null;
                            const rA = jB.querySelector('.reveal-answer-btn');
                            if(rA) rA.onclick=null; // Clear reveal button handler
                        }
                        const qText = bF?.querySelector('.question-text');
                        if (qText) qText.textContent = ''; // Clear the answer text on undo
                        cardEl.removeEventListener('click', handleCardClick);
                        cardEl.addEventListener('click', handleCardClick);
                        console.log(`Undo: Reverted card ${lastAction.cardKey} state.`);
                        activeCardElement = null;
                        disablePlayerSelectionMode();
                    } else { console.warn("Undo Card State Error: Card state or element not found", lastAction.cardKey); } } updatePlayerCards(); updateScoreDisplay(); drawScoreHistoryChart(); saveGameProgress(); updateUIbasedOnGameState(); } else if (lastAction) { historyStack.push(lastAction); updateUndoButtonState(); console.warn("Undo action type not implemented:", lastAction.action); } });
            if(resetScoresBtnElement) resetScoresBtnElement.addEventListener('click', () => { if (confirm("Are you sure you want to reset all player scores to $0? This cannot be undone.")) { historyStack = []; scoreHistory = {}; players.forEach(p => { p.score = 0; scoreHistory[p.id] = [{ turn: 0, score: 0 }]; }); turnCounter = 0; updatePlayerCards(); updateScoreDisplay(); updateUndoButtonState(); drawScoreHistoryChart(); saveGameProgress(); alert("All player scores have been reset to $0."); hideQuestionDisplay();} });
            if(newGameBtnElement) newGameBtnElement.addEventListener('click', () => { if (confirm("Are you sure you want to start a completely new game? All current progress (players, scores, board) will be lost.")) { localStorage.removeItem(STORAGE_KEY_GAME); players = []; currentPlayerId = null; gameStarted = false; boardState = {}; historyStack = []; scoreHistory = {}; answeredCluesCount = 0; currentWager = 0; turnCounter = 0; playerTurnIndex = 0; activeCardElement = null; if (activeChart) { activeChart.destroy(); activeChart = null; } const pSE = document.getElementById('player-setup'); if (pSE) pSE.style.display = 'flex'; if (playerListElement) playerListElement.innerHTML = ''; if (scorePanelElement) scorePanelElement.style.display = 'none'; if (boardElement) { boardElement.style.display = 'none'; boardElement.innerHTML = ''; } if (finalJeopardySectionElement) finalJeopardySectionElement.style.display = 'none'; if (victoryElement) victoryElement.style.display = 'none'; if (resultsModalElement) resultsModalElement.classList.remove('show'); if (playerNameInputElement) playerNameInputElement.value = ''; if (startGameBtnElement) startGameBtnElement.disabled = true; if (showFinalJeopardyBtnElement) showFinalJeopardyBtnElement.disabled = true; if (resetScoresBtnElement) resetScoresBtnElement.disabled = true; if (undoBtnElement) undoBtnElement.disabled = true; if(musicElement) { musicElement.pause(); musicElement.currentTime = 0; } disablePlayerSelectionMode(); updateScoreDisplay(); updateUndoButtonState(); hideQuestionDisplay(); const gameTabButton = document.querySelector('.tab-button[data-tab="game-tab"]'); if(gameTabButton && !gameTabButton.classList.contains('active')) gameTabButton.click(); alert("New game started. Please add players."); } });
            if(musicToggleElement) musicToggleElement.addEventListener('change', () => { if (musicToggleElement.checked && gameStarted && musicElement) { if (musicElement.paused) { playSound(musicElement); } } else if(musicElement) { musicElement.pause(); } });
            // NEW Event Listener for rotate control
            if(rotateControlToggleElement) {
                rotateControlToggleElement.addEventListener('change', () => {
                    rotateControlEnabled = rotateControlToggleElement.checked;
                    console.log(`Rotate Control is now: ${rotateControlEnabled ? 'Enabled' : 'Disabled'}`);
                    saveGameProgress(); // Save the new setting
                });
            }
            if(showFinalJeopardyBtnElement) showFinalJeopardyBtnElement.addEventListener('click', setupFinalJeopardy); // Kept, but button is disabled
            if(revealFinalQuestionBtnElement) revealFinalQuestionBtnElement.addEventListener('click', () => {
                if (finalQuestionElement) {
                    finalQuestionElement.style.display = 'block';
                    if (finalJeopardyData && finalJeopardyData.question) { // Ensure data is available
                        speakQuestion(finalJeopardyData.question);
                    }
                }
                revealFinalQuestionBtnElement.style.display = 'none';
                if (submitFinalWagersBtnElement) {
                    submitFinalWagersBtnElement.style.display = 'inline-block';
                    submitFinalWagersBtnElement.disabled = false;
                }
                const firstWagerInput = finalWagersContainerElement?.querySelector('input[type="number"]');
                if(firstWagerInput) firstWagerInput.focus();
            });
            if(submitFinalWagersBtnElement) submitFinalWagersBtnElement.addEventListener('click', () => { let allValid = true; const wagerInputs = finalWagersContainerElement?.querySelectorAll('.wager-row input[type="number"]'); if (!wagerInputs) return; wagerInputs.forEach(input => { const wager = parseInt(input.value, 10); const maxWager = parseInt(input.max, 10); if (isNaN(wager) || wager < 0 || wager > maxWager) { allValid = false; input.style.border = '2px solid red'; input.disabled = false; } else { input.style.border = ''; input.disabled = true; } }); if (!allValid) { alert("Please correct the invalid wagers (highlighted in red). Ensure they are numbers between $0 and the player's current score."); return; } submitFinalWagersBtnElement.disabled = true; if (judgeFinalAnswersBtnElement) judgeFinalAnswersBtnElement.style.display = 'inline-block'; alert("Wagers locked in. Reveal answers and judge."); });
            if(judgeFinalAnswersBtnElement) judgeFinalAnswersBtnElement.addEventListener('click', () => { // MODIFIED - Reveal answer after loop
                 finalWagersContainerElement?.querySelectorAll('.wager-row input[type="number"]').forEach(input => { const playerId = input.dataset.playerId; const wager = parseInt(input.value, 10); const player = getPlayerById(playerId); if (player && !isNaN(wager)) { const isCorrect = confirm(`Did ${player.name} answer the Final Jeopardy question correctly?`); const delta = isCorrect ? wager : -wager; turnCounter++; updatePlayerScore(playerId, delta, false, 'final_jeopardy'); } });
                 if (finalJeopardyData && finalQuestionElement) { finalQuestionElement.textContent = `${finalJeopardyData.question} (A: ${finalJeopardyData.answer})`; finalQuestionElement.style.display = 'block'; } // Reveal answer
                 if (judgeFinalAnswersBtnElement) judgeFinalAnswersBtnElement.style.display = 'none';
                 setTimeout(() => { if (finalJeopardySectionElement) finalJeopardySectionElement.style.display = 'none'; showFinalResults(); launchConfetti(); saveGameProgress(); }, 3000); // Delay results display
             });
            if(modalCloseElement) modalCloseElement.addEventListener('click', () => { if(resultsModalElement) resultsModalElement.classList.remove('show'); });
            if(saveHighScoresBtnElement) saveHighScoresBtnElement.addEventListener('click', saveScoresToHighScores);
        }

        // --- Initialization ---
        function initializeGame() {
            console.log("Initializing Quality Jeopardy v11 (Hide FJ Answer)...");
            setupTabs();
            setupEventListeners();
            loadGameProgress();
            renderHighScores();
            updateUndoButtonState();
        }

        // --- Start ---
        document.addEventListener('DOMContentLoaded', initializeGame);

    </script>
