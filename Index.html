<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quality Jeopardy - Enhanced Edition (Host Intervention)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Basic reset and box-sizing */
        *,
        *::before,
        *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* CSS Variables for theming */
        :root {
            --bg: #0b2345;             /* page background */
            --fg: #ffffff;             /* default text colour */
            --card-bg: #1e3a8a;        /* card / category background */
            --flip-duration: .6s;      /* Card flip animation speed */
            --score-bg: #02132c;       /* Score panel background */
            --correct-bg: #d4edda;     /* Background for correctly answered cards */
            --wrong-bg: #f8d7da;       /* Background for incorrectly answered cards */
            --jeopardy-border: 4px solid #ffeb3b; /* Potential border style */
            --player-1-color: #4caf50;  /* Player 1 color */
            --player-2-color: #2196f3;  /* Player 2 color */
            --player-3-color: #ff9800;  /* Player 3 color */
            --player-4-color: #e91e63;  /* Player 4 color */
            --active-player-bg: rgba(255, 255, 255, 0.2); /* Active player background */
            --disabled-card-bg: #4a4a4a;/* Added for DD visibility */
            --selectable-player-border: 3px dashed yellow; /* For player selection during steal */
            --pending-steal-shadow: 0 0 15px yellow; /* Glow for pending card */
            --failed-attempt-border: 2px solid #dc3545; /* Border for failed player during steal */
            --host-selectable-hover-bg: rgba(255, 255, 255, 0.1); /* Subtle hover for host intervention */
        }

        /* Body styles */
        body {
            font-family: Arial, Helvetica, sans-serif;
            line-height: 1.4;
            background: var(--bg);
            color: var(--fg);
            min-height: 100vh;
        }

        /* -------- Layout Wrapper -------- */
        #game-controls-wrapper {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 1.5rem;
            max-width: 1000px;
            margin: 1rem auto;
        }

        /* -------- Player Panel -------- */
        #player-panel {
            background: var(--score-bg);
            padding: 1rem;
            border-radius: 8px;
            flex: 1 1 400px;
            max-width: 450px;
            min-width: 280px;
        }

        #player-setup {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        #player-list {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            min-height: 50px;
        }

        .player-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 8px;
            width: 175px;
            position: relative;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            cursor: default; /* Default cursor, might be overridden */
        }

        /* NEW: General hover effect when host can select */
        .player-card.host-selectable:hover {
             background-color: var(--host-selectable-hover-bg);
             transform: scale(1.02);
        }


        .player-card.active-player {
            background: var(--active-player-bg);
            border-color: #ffeb3b;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            transform: scale(1.05); /* Keep active slightly larger */
        }
        .player-card.active-player:hover {
             transform: scale(1.05); /* Prevent hover scale down on active player */
        }

        /* Style for when player cards are clickable for answering during STEAL */
        .player-card.selectable-player {
            cursor: pointer;
            border: var(--selectable-player-border);
            opacity: 0.85;
        }
        .player-card.selectable-player:hover {
             opacity: 1;
             transform: scale(1.03); /* Slightly different scale for steal selection */
             box-shadow: 0 0 8px yellow;
             background-color: var(--active-player-bg); /* Use active bg for hover clarity */
        }
        /* Style to indicate a player has already failed on the current question during STEAL */
        .player-card.failed-attempt {
            opacity: 0.5;
            cursor: not-allowed !important; /* Force cursor */
            border: var(--failed-attempt-border);
        }
        .player-card.failed-attempt:hover {
             background-color: rgba(0, 0, 0, 0.3); /* Prevent hover change */
             transform: none; /* Prevent hover scale */
        }


        .player-name {
            font-weight: bold;
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            word-break: break-word;
        }

        .player-score {
            font-size: 1.5rem;
        }

        .player-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        /* -------- Score panel -------- */
        #score-panel {
            background: var(--score-bg);
            color: var(--fg);
            padding: 1rem;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: .75rem;
            flex: 1 1 400px;
            max-width: 450px;
             min-width: 280px;
        }

        #score-display {
            font-size: 1.3rem;
            text-align: center;
            font-weight: bold;
            min-height: 2em;
            background-color: rgba(0,0,0,0.2);
            padding: 0.5rem;
            border-radius: 4px;
        }
         /* Style for the status text */
        #score-display .status-text {
            display: block; /* Put on new line */
            font-size: 0.9rem;
            font-weight: normal;
            color: #ffeb3b; /* Yellow text */
            margin-top: 0.3rem;
        }


        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: .75rem;
        }

        /* Specific controls group for the 'No Other Takers' button */
        #steal-controls {
            margin-top: 0.5rem; /* Add some space */
        }
        #no-other-takers-btn {
             background-color: #6c757d; /* Greyish color */
        }

        input[type=number],
        input[type=text],
        button {
            padding: .4rem .6rem;
            font-size: .9rem;
            border-radius: 4px;
            border: 1px solid #ccc;
            background-color: #fff;
            color: #333;
        }

        button {
            cursor: pointer;
            background-color: var(--card-bg);
            color: var(--fg);
            border: 1px solid var(--fg);
            transition: background-color 0.3s;
        }

        button:hover:not(:disabled) {
            background-color: #2f4c9c;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input[type=number] { width: 100px; }
        input[type=checkbox] { width: auto; height: auto; margin-right: 5px; vertical-align: middle; cursor: pointer; }
        label[for="music-toggle"] { vertical-align: middle; cursor: pointer; }

        /* -------- Board & Card -------- */
        #board {
            display: grid;
            gap: 4px;
            max-width: 1000px;
            margin: 1.5rem auto;
        }

        .category {
            background: var(--card-bg);
            padding: 1rem;
            text-align: center;
            font-weight: 700;
            color: #ffeb3b;
            cursor: default;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card {
            perspective: 1000px;
            cursor: pointer;
            position: relative;
            min-height: 110px;
        }

        .card.disabled {
            pointer-events: none;
            cursor: default;
            opacity: 0.6; /* Make disabled cards slightly faded */
        }
        /* Style for card when it's open for another player */
        .card.pending-steal {
             box-shadow: var(--pending-steal-shadow); /* Yellow glow */
             cursor: default; /* Shouldn't be clickable directly */
             pointer-events: none; /* Prevent clicks on the card itself */
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform var(--flip-duration);
        }

        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            padding: .5rem;
            border-radius: 4px;
            overflow: hidden;
            text-align: center;
        }

        .card-front {
            background: var(--card-bg);
            color: #ffeb3b;
            font-weight: 700;
        }

        /* Style for the front of answered cards */
        .card-front.empty-value {
            background: var(--disabled-card-bg);
            color: #888;
        }
         /* Style for front of cards marked DD but not answered */
         .card.daily-double-marker .card-front {
              /* Optional: Add a subtle visual indicator for DD */
              /* border-left: 5px solid gold; */
         }

        .card-back {
            background: #ffffff;
            color: #000000;
            transform: rotateY(180deg);
            justify-content: space-around; /* Use space-around for better vertical spacing */
            font-size: clamp(.75rem, 1.6vw, 1.0rem); /* Font size adjusted in previous step */
            overflow-y: auto;
            padding: .75rem;
            line-height: 1.3; /* Optional: Adjust line spacing */
        }

        .question-text {
            margin-bottom: 0.5rem;
            flex-grow: 1; /* Allow question to take up space */
            overflow-y: auto; /* Scroll if needed */
            max-height: 75%; /* Allow slightly more height for text */
            width: 100%; /* Ensure it takes width */
        }

        .card.correct .card-front.empty-value,
        .card.correct .card-back {
            background: var(--correct-bg);
            color: #155724;
        }

        .card.wrong .card-front.empty-value,
        .card.wrong .card-back {
            background: var(--wrong-bg);
            color: #721c24;
        }

        /* Prevent hover on disabled/pending cards */
        .card:not(.disabled):not(.flipped):not(.pending-steal):hover .card-front {
            outline: 2px solid #fde047;
            transform: scale(1.05);
            transition: transform 0.2s ease, outline 0.2s ease;
        }

        .judge-buttons {
            margin-top: auto; /* Push to bottom */
            padding-top: .5rem;
            display: flex;
            gap: .5rem;
            flex-wrap: nowrap;
            justify-content: center;
            flex-shrink: 0; /* Prevent shrinking */
            width: 100%; /* Take full width */
        }

        .judge-buttons button {
            padding: .4rem .6rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
            font-size: clamp(.7rem, 2vw, .9rem);
        }

        .correct-btn { background-color: #28a745; color: white; }
        .wrong-btn { background-color: #dc3545; color: white; }

        /* -------- Other Sections -------- */
        #victory { display: none; text-align: center; padding: 2rem; font-size: 2rem; background: #10b981; color: #ffffff; margin: 1rem auto; border-radius: 8px; max-width: 600px; }
        #final-jeopardy { display: none; max-width: 800px; margin: 1rem auto; background: #1e3a8a; padding: 2rem; border-radius: 8px; border: var(--jeopardy-border); text-align: center; }
        #final-jeopardy h2 { color: #ffeb3b; font-size: 2rem; margin-bottom: 1rem; }
        #final-category { font-size: 1.5rem; margin-bottom: 1rem; font-weight: bold; }
        #final-question { background: #fff; color: #000; padding: 1.5rem; border-radius: 8px; margin: 1.5rem 0; font-size: 1.4rem; line-height: 1.5; }
        .final-wagers { display: flex; flex-direction: column; gap: 1rem; margin-top: 1.5rem; align-items: center; }
        .wager-row { display: flex; justify-content: center; align-items: center; gap: 1rem; width: 100%; max-width: 400px; }
        .wager-row label { flex: 1; text-align: right; font-weight: bold; }
        .wager-row input { flex: 1; max-width: 150px; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); align-items: center; justify-content: center; }
        .modal.show { display: flex; }
        .modal-content { background-color: var(--score-bg); padding: 2rem; border-radius: 8px; max-width: 600px; width: 90%; position: relative; text-align: center; }
        .modal-close { position: absolute; top: 10px; right: 15px; font-size: 1.8rem; font-weight: bold; color: #aaa; cursor: pointer; transition: color 0.3s; }
        .modal-close:hover { color: #fff; }
        #final-results div { font-size: 1.2rem; margin-bottom: 0.5rem; }
        #final-results div:last-child { margin-bottom: 1.5rem; }
        #high-scores { max-width: 600px; margin: 1rem auto; background: var(--score-bg); padding: 1rem; border-radius: 8px; }
        #high-scores h2 { text-align: center; margin-bottom: 1rem; color: #ffeb3b; }
        #high-scores-list { list-style-type: decimal; margin-top: 1rem; padding-left: 2rem; }
        #high-scores-list li { display: flex; justify-content: space-between; padding: 0.5rem; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        #high-scores-list li span:last-child { font-weight: bold; }
        .confetti { position: fixed; width: 10px; height: 10px; background-color: #f00; opacity: 0.7; z-index: 1001; animation: fall linear forwards; top: -20px; pointer-events: none; }
        @keyframes fall { to { transform: translateY(105vh) rotate(720deg); opacity: 0; } }

        /* Media Queries */
        @media(max-width: 768px) {
            #game-controls-wrapper { max-width: 95%; gap: 1rem; }
            #player-panel, #score-panel { flex-basis: 300px; }
            #board { gap: 3px; }
            .category { font-size: 0.8rem; padding: 0.5rem; }
            #game-title { font-size: 3rem; }
            .player-card { width: 150px; }
        }
        @media(max-width: 650px) {
             #game-controls-wrapper { flex-direction: column; align-items: center; }
              #player-panel, #score-panel { max-width: 95%; width: 100%; flex-basis: auto; }
             .category { font-size: .75rem; padding: .4rem }
             #score-panel, #player-panel, #high-scores, #final-jeopardy { width: 95%; max-width: 95%; }
             #game-title { font-size: 2.2rem; }
             .player-card { width: calc(50% - 1rem); }
             .controls { justify-content: center; gap: .5rem;}
             button, input { font-size: 0.8rem; padding: 0.3rem 0.5rem; }
             #final-question { font-size: 1.1rem; }
             .wager-row { flex-direction: column; align-items: center; gap: 0.5rem; }
             .wager-row label { text-align: center; margin-bottom: 0.2rem; }
             .wager-row input { max-width: 120px; }
             .tabs button { font-size: 0.8rem; padding: 0.4rem 0.6rem;}
        }

        /* Title Font */
        @import url("https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap");
        #game-title { font-family: 'Orbitron', sans-serif; font-weight: 900; font-size: 4rem; color: gold; text-align: center; margin: 1rem 0; text-shadow: 2px 2px 4px rgba(0, 0, 0, .7); }

        /* Tabs */
        .tabs { display: flex; justify-content: center; gap: 0.5rem; margin: 1rem auto; max-width: 800px; flex-wrap: wrap; }
        .tab-button { padding: 0.5rem 1rem; border: none; background: var(--card-bg); color: #fff; border-radius: 4px 4px 0 0; cursor: pointer; transition: background 0.3s; }
        .tab-button:hover, .tab-button.active { background: #2f4c9c; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* Score History Chart */
        #score-history-chart-container { min-height: 300px; background: rgba(0, 0, 0, 0.2); display: flex; align-items: center; justify-content: center; color: #ccc; border-radius: 8px; margin-top: 1rem; padding: 1rem; position: relative; }
        #score-history-chart { display: block; max-width: 100%; }
        #chart-placeholder-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }

    </style>
</head>

<body>
    <header>
        <h1 id="game-title">QUALITY JEOPARDY</h1>
    </header>

    <!-- Tab Navigation -->
    <div class="tabs">
        <button class="tab-button active" data-tab="game-tab">Game</button>
        <button class="tab-button" data-tab="score-history-tab">Score History</button>
        <button class="tab-button" data-tab="high-scores-tab">High Scores</button>
    </div>

    <!-- Game Tab Content -->
    <div id="game-tab" class="tab-content active">
        <div id="game-controls-wrapper">
            <!-- Player Setup and Management -->
            <section id="player-panel" aria-label="Player Management">
                <div id="player-setup">
                    <div class="controls">
                        <input id="player-name" type="text" placeholder="Player Name" aria-label="Player Name" />
                        <button id="add-player">Add Player</button>
                        <button id="start-game" disabled>Start Game</button>
                    </div>
                </div>
                <div id="player-list"><!-- Player cards will be added here by JS --></div>
            </section>

            <!-- Score Panel -->
            <section id="score-panel" aria-label="Score Control Panel" style="display: none;">
                <div id="score-display" aria-live="polite">Player: Score $0</div>
                <div class="controls">
                    <input id="manual-score" type="number" step="100" aria-label="Manual score adjustment for current player" placeholder="Set Score" />
                    <button id="apply-score" aria-label="Apply manual score to current player">Update Player Score</button>
                </div>
                <div class="controls">
                    <button id="undo-score" disabled>Undo Last Score</button>
                    <button id="reset-all-scores" disabled>Reset All Scores</button>
                    <button id="new-game">New Game</button>
                </div>
                <div class="controls">
                    <label for="music-toggle">Music</label>
                    <input type="checkbox" id="music-toggle" checked />
                    <button id="show-final-jeopardy" disabled>Final Jeopardy</button>
                </div>
                 <!-- Controls specifically for the steal/pass situation -->
                 <div class="controls" id="steal-controls" style="display: none;">
                      <button id="no-other-takers-btn">No Other Takers / Pass</button>
                 </div>
            </section>
        </div><!-- End of game-controls-wrapper -->


        <!-- Final Jeopardy Section -->
        <section id="final-jeopardy" aria-label="Final Jeopardy Round">
             <h2>FINAL JEOPARDY</h2>
            <div id="final-category">Category: Loading...</div>
            <div id="final-question" style="display: none;">Question text...</div>
            <button id="reveal-final-question">Reveal Question</button>
            <div class="final-wagers" id="final-wagers"></div>
            <div class="controls">
                <button id="submit-final-wagers" style="display: none;">Lock In Wagers</button>
                <button id="judge-final-answers" style="display: none;">Judge Final Answers</button>
            </div>
        </section>

        <!-- Audio Elements -->
        <audio id="bg-music" src="Jeopardy - 2008 - Opening.mp3" loop preload="auto"></audio>
        <audio id="correct-sound" src="sounds/correct.mp3" preload="auto"></audio>
        <audio id="wrong-sound" src="sounds/wrong.mp3" preload="auto"></audio>
        <audio id="daily-double-sound" src="sounds/daily_double.mp3" preload="auto"></audio>
        <audio id="final-jeopardy-sound" src="sounds/final_jeopardy.mp3" preload="auto"></audio>

        <!-- Game Board -->
        <section id="board" aria-label="Jeopardy Game Board" style="display: none;"></section>
        <div id="victory" role="alert">Congratulations! You've cleared the board! Prepare for Final Jeopardy!</div>
    </div><!-- End of game-tab -->

    <!-- Score History Tab Content -->
    <div id="score-history-tab" class="tab-content">
         <section id="score-history-container">
             <h2>Score Progression</h2>
            <div id="score-history-chart-container">
                <canvas id="score-history-chart"></canvas>
                 <p id="chart-placeholder-text">(Score history will appear here)</p>
            </div>
        </section>
    </div><!-- End of score-history-tab -->

    <!-- High Scores Tab Content -->
    <div id="high-scores-tab" class="tab-content">
         <section id="high-scores">
             <h2>High Scores</h2>
            <ul id="high-scores-list">
                <li>No scores saved yet.</li>
            </ul>
        </section>
    </div><!-- End of high-scores-tab -->

    <!-- Results Modal -->
    <div id="results-modal" class="modal">
        <div class="modal-content">
             <span class="modal-close" title="Close">×</span>
            <h2>Game Results</h2>
            <div id="final-results"></div>
            <button id="save-high-scores">Save to High Scores</button>
        </div>
    </div>

    <script type="module">
        // --- Constants ---
        const STORAGE_KEY_GAME = 'quality_jeopardy_game_progress_v6_' + location.pathname; // Increment version
        const STORAGE_KEY_SCORES = 'quality_jeopardy_high_scores_v1';
        const PLAYER_COLORS = ['#4caf50', '#2196f3', '#ff9800', '#e91e63', '#9c27b0', '#00bcd4', '#f44336', '#ffc107'];
        const MIN_WAGER = 5;
        const DAILY_DOUBLE_MAX_WAGER_BASE = 1000;

        // --- Game Data ---
        const gameData = {
             categories: [ { name: 'Food Safety', clues: [200, 400, 600, 800, 1000] }, { name: 'GMPs', clues: [200, 400, 600, 800, 1000] }, { name: 'FSMA', clues: [200, 400, 600, 800, 1000] }, { name: 'Allergens', clues: [200, 400, 600, 800, 1000] }, { name: 'HACCP', clues: [200, 400, 600, 800, 1000] }, { name: 'Chocolate', clues: [200, 400, 600, 800, 1000] } ]
        };
        const questionBank = {
            'Food Safety': [
        'The number of major food allergens recognized by the US FDA.',
        'Many consumers mistakenly consider this a food allergen; perhaps it should not be listed in this category.',
        'The maximum amount of peanuts allowed in a food that does NOT require a "Contains: peanuts" label.',
        'Examples of advisory statements that are NOT required by FALCPA (Food Allergen Labeling and Consumer Protection Act of 2004).',
        'FALCPA requires manufacturers to declare when a product contains an allergen OR contains this component from a major allergen.'
      ],
      'GMPs':        ['Define  it..','What all employees must do when returning from the restroom','Experts recommend reciting the ABC’s or singing “Happy Birthday” to ensure proper contact time when doing this','The only type of jewelry allowed to be worn on the plant floor','Employees with this are not permitted to work with food products'],
      'FSMA':        [
        'January 4, 2011', // Question 1 for FSMA
        'Non-binding published regulations; they do not have the rule of law .. yet', // Question 2 for FSMA
        'Every year, 1 out of this number of people in the United State suffers from foodborne illness, That’s 48 million people!', // Question 3 for FSMA
        'The Hourly rate the FDA charges for re-inspection of a domestic food facility', // Question 4 for FSMA
        'For the first time, FDA has this authority for all food products' // Question 5 for FSMA
      ],
      'Allergens':   [
        'The number of major food allergens recognized by the US FDA', // Question 1 for Allergens
        'Many consumers mistakenly consider this a food allergen; perhaps it should not be mentioned in this category', // Question 2 for Allergens
        'This is the amount of peanuts allowed in a food that does NOT have to be labeled as “Contains: peanuts”.', // Question 3 for Allergens
        'Advisory statements that are not required by FALCPA (Food Allergen Labeling and Consumer Protection Act of 2004)', // Question 4 for Allergens
        'FALCPA requires food manufacturers to label food products that contain an allergen or contains this from a major food allergen' // Question 5 for Allergens
      ],
      'HACCP':       [
        'The “HA” in HACCP', // Question 1 for HACCP
        'The “CCP” in HACCP', // Question 2 for HACCP
        'A point, step or procedure at which controls can be applied and a food safety hazard can be prevented, eliminated or reduced to acceptable levels', // Question 3 for HACCP
        'These are the supporting programs that with CCP’s make up a Food Safety System', // Question 4 for HACCP
        'FSMA HACCP' // Question 5 for HACCP
      ],
      'Chocolate':   [
        'A confection made from roasted cocoa beans, sugar, and milk', // Question 1 for Chocolate
        'A light to medium brown shade', // Question 2 for Chocolate
        'Sweet, creamy, and sometimes slightly bitter', // Question 3 for Chocolate
        'The chocolate treat you enjoy the most', // Question 4 for Chocolate
        'Warm, tropical regions near the equator, such as West Africa or South America.' // Question 5 for Chocolate
      ]

        };
        const finalJeopardyQuestions = [ { category: "Cat 1", question: "FJ Q1 (A: A)" }, { category: "Cat 2", question: "FJ Q2 (A: B)" }, { category: "Cat 3", question: "FJ Q3 (A: C)" } ];
        let finalJeopardyData = null;

        // --- State Variables ---
        let players = []; let currentPlayerId = null; let gameStarted = false; let boardState = {};
        let historyStack = []; let scoreHistory = {}; let currentWager = 0; let answeredCluesCount = 0;
        let turnCounter = 0; let playerTurnIndex = 0; let activeChart = null; let activeCardElement = null;

        // --- Calculated Values ---
        const numCategories = gameData.categories.length; const numCluesPerCat = gameData.categories[0]?.clues?.length ?? 0; const totalClues = numCategories * numCluesPerCat;

        // --- DOM References ---
        const boardElement = document.getElementById('board'); const victoryElement = document.getElementById('victory'); const musicElement = document.getElementById('bg-music'); const musicToggleElement = document.getElementById('music-toggle'); const addPlayerBtnElement = document.getElementById('add-player'); const startGameBtnElement = document.getElementById('start-game'); const playerNameInputElement = document.getElementById('player-name'); const playerListElement = document.getElementById('player-list'); const scorePanelElement = document.getElementById('score-panel'); const scoreDisplayElement = document.getElementById('score-display'); const manualScoreInputElement = document.getElementById('manual-score'); const applyScoreBtnElement = document.getElementById('apply-score'); const undoBtnElement = document.getElementById('undo-score'); const resetScoresBtnElement = document.getElementById('reset-all-scores'); const newGameBtnElement = document.getElementById('new-game'); const showFinalJeopardyBtnElement = document.getElementById('show-final-jeopardy'); const finalJeopardySectionElement = document.getElementById('final-jeopardy'); const finalCategoryElement = document.getElementById('final-category'); const finalQuestionElement = document.getElementById('final-question'); const revealFinalQuestionBtnElement = document.getElementById('reveal-final-question'); const submitFinalWagersBtnElement = document.getElementById('submit-final-wagers'); const judgeFinalAnswersBtnElement = document.getElementById('judge-final-answers'); const finalWagersContainerElement = document.getElementById('final-wagers'); const resultsModalElement = document.getElementById('results-modal'); const finalResultsElement = document.getElementById('final-results'); const saveHighScoresBtnElement = document.getElementById('save-high-scores'); const modalCloseElement = document.querySelector('.modal-close'); const scoreHistoryContainerElement = document.getElementById('score-history-container'); const scoreHistoryChartCanvas = document.getElementById('score-history-chart'); const chartPlaceholderText = document.getElementById('chart-placeholder-text'); const highScoresListElement = document.getElementById('high-scores-list'); const correctSound = document.getElementById('correct-sound'); const wrongSound = document.getElementById('wrong-sound'); const dailyDoubleSound = document.getElementById('daily-double-sound'); const finalJeopardySound = document.getElementById('final-jeopardy-sound'); const stealControlsElement = document.getElementById('steal-controls'); const noOtherTakersBtnElement = document.getElementById('no-other-takers-btn');

        // --- Functions ---

        function getPlayerById(playerId) { return players.find(p => p.id === playerId); }

        function updatePlayerScore(playerId, delta, isUndo = false, cardKey = null) {
            const player = getPlayerById(playerId);
            if (player) { const oldScore = player.score; player.score += delta; const newScore = player.score; console.log(`Score Update: ${player.name} ${oldScore} -> ${newScore} (Delta: ${delta}, Turn: ${turnCounter})`); if (!scoreHistory[playerId]) scoreHistory[playerId] = []; scoreHistory[playerId].push({ turn: turnCounter, score: newScore }); if (!isUndo) { historyStack.push({ action: 'score', playerId: playerId, delta: delta, turn: turnCounter, cardKey: cardKey }); updateUndoButtonState(); } updatePlayerCards(); updateScoreDisplay(); drawScoreHistoryChart(); }
            else { console.error("Player not found for score update:", playerId); }
            if (!isUndo) saveGameProgress();
        }

        function nextPlayerTurnRegular() {
            if (players.length <= 1) return; playerTurnIndex = (playerTurnIndex + 1) % players.length; currentPlayerId = players[playerTurnIndex]?.id; turnCounter++; console.log(`Regular Turn ${turnCounter}: ${players[playerTurnIndex]?.name}'s turn (Index: ${playerTurnIndex})`); updatePlayerCards(); updateScoreDisplay(); saveGameProgress();
        }

        function setActivePlayer(playerId, isHostIntervention = false) { // Added flag
            const player = getPlayerById(playerId);
            if (player) {
                const previousPlayerId = currentPlayerId;
                currentPlayerId = playerId;
                const newIndex = players.findIndex(p => p.id === playerId);
                if (newIndex !== -1) playerTurnIndex = newIndex;

                // Increment turn counter ONLY if it's a host intervention changing the player
                if (isHostIntervention && previousPlayerId !== playerId) {
                    turnCounter++;
                    console.log(`Host Intervention (Turn ${turnCounter}): Set Active Player to ${player.name} (Index: ${playerTurnIndex})`);
                    // Maybe add to history stack? For now, keep undo simple.
                    // historyStack.push({ action: 'host_select', oldPlayerId: previousPlayerId, newPlayerId: playerId, turn: turnCounter });
                    // updateUndoButtonState();
                } else {
                    console.log(`Set Active Player: ${player.name} (Index: ${playerTurnIndex}) (No turn count change)`);
                }

                updatePlayerCards(); updateScoreDisplay(); saveGameProgress();
            } else { console.error("Attempted to set active player to non-existent ID:", playerId); }
        }

        // NEW: Handler for host clicking player card outside of steal mode
        function handleHostPlayerSelection(event) {
            const selectedPlayerCard = event.currentTarget;
            const selectedPlayerId = selectedPlayerCard.dataset.playerId;

            // --- Guard Clauses for Host Intervention ---
            // 1. Game must be started
            if (!gameStarted) return;
            // 2. Not during Final Jeopardy
            if (finalJeopardySectionElement.style.display === 'block') {
                console.log("Host selection blocked: Final Jeopardy active.");
                return;
            }
            // 3. Not while a card is flipped and awaiting judgement/steal decision
            if (activeCardElement) {
                 alert("Cannot change player while a question is active. Please resolve it first.");
                 console.log("Host selection blocked: Question active", activeCardElement.dataset.stateKey);
                 return;
            }
            // 4. Not while steal selection mode is active (different handler used)
            if (stealControlsElement.style.display === 'flex') {
                 console.log("Host selection blocked: Steal selection active.");
                 return;
            }
             // 5. Player ID must be valid
             if (!selectedPlayerId) {
                  console.warn("Host selection failed: No player ID on card.");
                  return;
             }
            // --- End Guard Clauses ---

            console.log(`Host selecting player: ${getPlayerById(selectedPlayerId)?.name}`);
            setActivePlayer(selectedPlayerId, true); // Pass true for host intervention flag
        }


        function updatePlayerCards() {
            if (!playerListElement) return;
            const isSelectionModeActive = !!document.querySelector('.card.pending-steal');
            const activeCardStateKey = activeCardElement?.dataset?.stateKey;
            const failedPlayerIds = activeCardStateKey ? (boardState[activeCardStateKey]?.failedPlayerIds || []) : [];

            playerListElement.innerHTML = '';
            players.forEach(player => {
                const card = document.createElement('div');
                card.className = 'player-card';
                card.dataset.playerId = player.id;

                // Base elements
                const indicator = document.createElement('div'); indicator.className = 'player-indicator'; indicator.style.backgroundColor = player.color;
                const nameElem = document.createElement('div'); nameElem.className = 'player-name'; nameElem.textContent = player.name || 'Unnamed Player';
                const scoreElem = document.createElement('div'); scoreElem.className = 'player-score'; scoreElem.textContent = `$${player.score}`;
                card.appendChild(indicator); card.appendChild(nameElem); card.appendChild(scoreElem);

                // Remove previous listeners first
                card.removeEventListener('click', handlePlayerCardClickForAnswer);
                card.removeEventListener('click', handleHostPlayerSelection);
                card.classList.remove('selectable-player', 'failed-attempt', 'host-selectable'); // Clear dynamic classes

                // Apply state classes and listeners
                if (player.id === currentPlayerId && gameStarted) card.classList.add('active-player');

                if (isSelectionModeActive) {
                    // --- Steal Mode ---
                    if (failedPlayerIds.includes(player.id)) {
                        card.classList.add('failed-attempt');
                        card.style.cursor = 'not-allowed';
                    } else {
                        card.classList.add('selectable-player');
                        card.style.cursor = 'pointer';
                        card.addEventListener('click', handlePlayerCardClickForAnswer); // Listener for steal answer
                    }
                } else if (gameStarted && finalJeopardySectionElement.style.display !== 'block') {
                    // --- Normal Game Mode (Host Intervention Enabled) ---
                    card.classList.add('host-selectable'); // Add class for potential styling/hover
                    card.style.cursor = 'pointer';
                    card.addEventListener('click', handleHostPlayerSelection); // Add host intervention listener
                } else {
                    // --- Game Not Started or Final Jeopardy ---
                     card.style.cursor = 'default'; // Not clickable
                }

                playerListElement.appendChild(card);
            });
        }


        function updateScoreDisplay() {
            if (!scoreDisplayElement) return; let mainText = ""; let statusText = ""; if (activeCardElement && activeCardElement.classList.contains('pending-steal')) statusText = "Select next player to answer or 'No Takers'"; if (currentPlayerId && gameStarted) { const player = getPlayerById(currentPlayerId); if(player) mainText = `Turn: ${player.name} | Score: $${player.score}`; else mainText = "Waiting for player..."; } else if (!gameStarted) mainText = "Add players and start game"; else mainText = "Game Over"; scoreDisplayElement.innerHTML = mainText + (statusText ? `<span class="status-text">${statusText}</span>` : "");
        }

        function generateBoard() {
            if (!boardElement) return; boardElement.innerHTML = ''; boardElement.style.gridTemplateColumns = `repeat(${numCategories}, 1fr)`; gameData.categories.forEach(cat => { const d = document.createElement('div'); d.className = 'category'; d.textContent = cat.name; boardElement.appendChild(d); }); for (let r = 0; r < numCluesPerCat; r++) { for (let c = 0; c < numCategories; c++) { const v = gameData.categories[c]?.clues[r] ?? 0; const catN = gameData.categories[c]?.name ?? 'Unknown'; const qT = questionBank[catN]?.[r] ?? 'Question not found!'; const id = `card-${c}-${r}`; const key = `${c}-${r}`; const card = document.createElement('div'); card.className = 'card'; card.id = id; card.dataset.catIndex = c; card.dataset.rowIndex = r; card.dataset.value = v; card.dataset.stateKey = key; const inner = document.createElement('div'); inner.className = 'card-inner'; const front = document.createElement('div'); front.className = 'card-face card-front'; const back = document.createElement('div'); back.className = 'card-face card-back'; back.innerHTML = `<div class="question-text">${qT}</div><div class="judge-buttons" style="display: none;"><button class="correct-btn">Correct</button><button class="wrong-btn">Wrong</button></div>`; inner.appendChild(front); inner.appendChild(back); card.appendChild(inner); const state = boardState[key]; const isAnswered = state?.state === 'correct' || state?.state === 'wrong'; const isPending = state?.failedPlayerIds?.length > 0 && !state.state; if (isAnswered) { card.classList.add('disabled', state.state); front.textContent = ''; front.classList.add('empty-value'); } else { front.textContent = `$${v}`; if (!isPending) card.addEventListener('click', handleCardClick); if (state?.isDailyDouble) card.classList.add('daily-double-marker'); if (isPending) { console.log(`generateBoard: Found pending card ${key}`); card.classList.add('flipped', 'pending-steal'); const jB = card.querySelector('.judge-buttons'); if (jB) jB.style.display = 'flex'; } } boardElement.appendChild(card); } } boardElement.style.display = 'grid';
        }

        function handleCardClick(event) {
            const card = event.currentTarget; const stateKey = card.dataset.stateKey; const currentState = boardState[stateKey] || {}; const isAnyCardPending = !!document.querySelector('.card.pending-steal'); if (isAnyCardPending) { alert("Please resolve the current question first."); return; } if (!gameStarted || !currentPlayerId) { console.warn("Card click ignored: Game not started/no player."); return; } if (card.classList.contains('flipped') || card.classList.contains('disabled')) { console.log("Card click ignored: Card resolved/judging."); return; } if (currentState.failedPlayerIds?.includes(currentPlayerId)) { alert(`${getPlayerById(currentPlayerId)?.name}, you already failed.`); return; } if (activeCardElement && activeCardElement !== card) { alert("Resolve current question first."); return; } console.log(`Card ${stateKey} clicked by ${getPlayerById(currentPlayerId)?.name}`); activeCardElement = card; card.classList.add('flipped'); const value = parseInt(card.dataset.value, 10); const judgeButtons = card.querySelector('.judge-buttons'); const isDailyDouble = currentState.isDailyDouble ?? false; if (!boardState[stateKey]) boardState[stateKey] = {}; if (isDailyDouble) { playSound(dailyDoubleSound); console.log("DD!"); let wager=NaN; const player=getPlayerById(currentPlayerId); if(!player) return; const maxW=Math.max(DAILY_DOUBLE_MAX_WAGER_BASE, player.score > 0 ? player.score : DAILY_DOUBLE_MAX_WAGER_BASE); while(isNaN(wager)||wager<MIN_WAGER||wager>maxW) { const wI=prompt(`DAILY DOUBLE!\n${player.name}, wager (min $${MIN_WAGER}, max $${maxW}):`); if(wI===null){wager=MIN_WAGER;break;} wager=parseInt(wI,10); if(isNaN(wager)||wager<MIN_WAGER||wager>maxW) alert(`Invalid wager...`); } currentWager=wager; console.log(`${player.name} wagered $${currentWager}`); } else { currentWager=value; } if (judgeButtons) { judgeButtons.style.display = 'flex'; const cBtn = judgeButtons.querySelector('.correct-btn'); const wBtn = judgeButtons.querySelector('.wrong-btn'); cBtn.onclick = null; wBtn.onclick = null; cBtn.onclick = (e) => { e.stopPropagation(); judgeAnswer(card, true, currentWager, isDailyDouble); }; wBtn.onclick = (e) => { e.stopPropagation(); judgeAnswer(card, false, currentWager, isDailyDouble); }; } disablePlayerSelectionMode(); saveGameProgress();
        }

        function enablePlayerSelectionMode(showButton = true) {
            if (!activeCardElement) { console.warn("Enable Steal Mode: No active card."); return; } const stateKey = activeCardElement.dataset.stateKey; if (!stateKey || !boardState[stateKey]) { console.warn("Enable Steal Mode: Invalid state."); return; } console.log("Entering steal selection mode:", stateKey); activeCardElement.classList.add('pending-steal'); updatePlayerCards(); if (showButton && stealControlsElement && noOtherTakersBtnElement) { stealControlsElement.style.display = 'flex'; noOtherTakersBtnElement.onclick = null; noOtherTakersBtnElement.onclick = handleNoOtherTakersClick; } updateScoreDisplay(); console.log("Steal selection enabled.");
        }

        function disablePlayerSelectionMode() {
            if (stealControlsElement) stealControlsElement.style.display = 'none'; if (activeCardElement) activeCardElement.classList.remove('pending-steal'); updatePlayerCards(); updateScoreDisplay(); console.log("Steal/Host selection modes disabled.");
        }

        function handlePlayerCardClickForAnswer(event) { // ONLY for steal attempts
            const selectedPlayerCard = event.currentTarget; const selectedPlayerId = selectedPlayerCard.dataset.playerId; if (!activeCardElement || !selectedPlayerId) { console.warn("Steal Click: No active Q/ID."); return; } console.log(`Player ${getPlayerById(selectedPlayerId)?.name} selected for steal.`); setActivePlayer(selectedPlayerId, false); disablePlayerSelectionMode();
        }

        function handleNoOtherTakersClick() { // ONLY for steal attempts
            if (!activeCardElement) { console.warn("No Takers: No active card."); return; } const stateKey = activeCardElement.dataset.stateKey; console.log("No takers for:", stateKey); boardState[stateKey].state = 'wrong'; answeredCluesCount++; console.log("Answered:", answeredCluesCount, "/", totalClues); activeCardElement.classList.remove('flipped', 'pending-steal'); activeCardElement.classList.add('disabled', 'wrong'); activeCardElement.removeEventListener('click', handleCardClick); const fF = activeCardElement.querySelector('.card-front'); if (fF) { fF.textContent = ''; fF.classList.add('empty-value'); } const jB = activeCardElement.querySelector('.judge-buttons'); if (jB) { jB.style.display = 'none'; const c=jB.querySelector('.correct-btn'); if(c)c.onclick=null; const w=jB.querySelector('.wrong-btn'); if(w)w.onclick=null; } disablePlayerSelectionMode(); activeCardElement = null; currentWager = 0; nextPlayerTurnRegular(); if (answeredCluesCount >= totalClues) showVictory();
        }

        function judgeAnswer(card, isCorrect, amount, isDailyDouble = false) {
            const stateKey = card?.dataset?.stateKey; if (!currentPlayerId || !card || !stateKey) { console.error("JudgeAnswer missing data", { currentPlayerId, card, stateKey }); return; } if (!boardState[stateKey]) boardState[stateKey] = {}; const delta = isCorrect ? amount : -amount; const playerBeingJudgedId = currentPlayerId; console.log(`Judging ${getPlayerById(playerBeingJudgedId)?.name} on ${stateKey}. Correct: ${isCorrect}, Amount: ${delta}, DD: ${isDailyDouble}`); turnCounter++; updatePlayerScore(playerBeingJudgedId, delta, false, stateKey); playSound(isCorrect ? correctSound : wrongSound); if (isCorrect) { console.log(`Correct. Question resolved.`); boardState[stateKey].state = 'correct'; boardState[stateKey].playerId = playerBeingJudgedId; boardState[stateKey].failedPlayerIds = boardState[stateKey].failedPlayerIds || []; answeredCluesCount++; console.log("Answered:", answeredCluesCount, "/", totalClues); card.classList.remove('flipped', 'pending-steal'); card.classList.add('disabled', 'correct'); card.removeEventListener('click', handleCardClick); const fF = card.querySelector('.card-front'); if (fF) { fF.textContent = ''; fF.classList.add('empty-value'); } const jB = card.querySelector('.judge-buttons'); if (jB) { jB.style.display = 'none'; const c=jB.querySelector('.correct-btn'); if(c)c.onclick=null; const w=jB.querySelector('.wrong-btn'); if(w)w.onclick=null; } disablePlayerSelectionMode(); activeCardElement = null; currentWager = 0; if (isDailyDouble) { console.log("Correct DD, next turn."); nextPlayerTurnRegular(); } else { console.log("Correct, keep control."); setActivePlayer(playerBeingJudgedId, false); } if (answeredCluesCount >= totalClues) showVictory(); } else { console.log(`Incorrect.`); if (!boardState[stateKey].failedPlayerIds) boardState[stateKey].failedPlayerIds = []; if (!boardState[stateKey].failedPlayerIds.includes(playerBeingJudgedId)) { boardState[stateKey].failedPlayerIds.push(playerBeingJudgedId); console.log("Failed players:", boardState[stateKey].failedPlayerIds); } boardState[stateKey].state = null; const eligibleCount = players.filter(p => !boardState[stateKey].failedPlayerIds.includes(p.id)).length; console.log(`Eligible remaining: ${eligibleCount}`); if (isDailyDouble || eligibleCount === 0) { console.log(isDailyDouble ? "DD incorrect. Resolved." : "All failed. Resolved."); boardState[stateKey].state = 'wrong'; answeredCluesCount++; console.log("Answered:", answeredCluesCount, "/", totalClues); card.classList.remove('flipped', 'pending-steal'); card.classList.add('disabled', 'wrong'); card.removeEventListener('click', handleCardClick); const fF = card.querySelector('.card-front'); if (fF) { fF.textContent = ''; fF.classList.add('empty-value'); } const jB = card.querySelector('.judge-buttons'); if (jB) { jB.style.display = 'none'; const c=jB.querySelector('.correct-btn'); if(c)c.onclick=null; const w=jB.querySelector('.wrong-btn'); if(w)w.onclick=null; } disablePlayerSelectionMode(); activeCardElement = null; currentWager = 0; console.log("Next regular turn."); nextPlayerTurnRegular(); if (answeredCluesCount >= totalClues) showVictory(); } else { console.log("Incorrect. Enable selection."); enablePlayerSelectionMode(); saveGameProgress(); } }
        }

        function determineDailyDouble() { if (totalClues === 0) return; Object.keys(boardState).forEach(key => { if (boardState[key]) boardState[key].isDailyDouble = false; }); const pI = []; for (let r = 1; r < numCluesPerCat; r++) { for (let c = 0; c < numCategories; c++) { const k = `${c}-${r}`; if (!boardState[k]?.state && !boardState[k]?.failedPlayerIds?.length) pI.push(k); } } if (pI.length > 0) { const rI = Math.floor(Math.random() * pI.length); const ddK = pI[rI]; if (!boardState[ddK]) boardState[ddK] = {}; boardState[ddK].isDailyDouble = true; console.log("DD location:", ddK); } else console.log("Could not place DD."); }
        function saveGameProgress() { if (!gameStarted && players.length === 0 && !Object.keys(boardState).length) return; const state = { gameStarted, players: players.map(p => ({ ...p })), currentPlayerId, playerTurnIndex, boardState: JSON.parse(JSON.stringify(boardState)), historyStack: [...historyStack], answeredCluesCount, turnCounter, scoreHistory: JSON.parse(JSON.stringify(scoreHistory)) }; try { localStorage.setItem(STORAGE_KEY_GAME, JSON.stringify(state)); } catch (e) { console.error("Save Error:", e); } }
        function loadGameProgress() { const savedState = localStorage.getItem(STORAGE_KEY_GAME); if (savedState) { try { const state = JSON.parse(savedState); if (state && typeof state === 'object' && Array.isArray(state.players)) { gameStarted = state.gameStarted ?? false; players = state.players ?? []; currentPlayerId = state.currentPlayerId ?? (players.length > 0 ? players[0].id : null); playerTurnIndex = state.playerTurnIndex ?? (players.findIndex(p => p.id === currentPlayerId) ?? 0); boardState = state.boardState ?? {}; historyStack = state.historyStack ?? []; answeredCluesCount = state.answeredCluesCount ?? Object.values(boardState).filter(s => s?.state === 'correct' || s?.state === 'wrong').length; turnCounter = state.turnCounter ?? 0; scoreHistory = state.scoreHistory ?? {}; activeCardElement = null; console.log("Game loaded."); updateUIbasedOnGameState(); updateUndoButtonState(); const pendingKey = Object.keys(boardState).find(key => boardState[key]?.failedPlayerIds?.length > 0 && !boardState[key].state); if (pendingKey) { activeCardElement = document.getElementById(`card-${pendingKey.replace('-', '-')}`); if (activeCardElement) { console.log("Loaded into pending state:", pendingKey); enablePlayerSelectionMode(); } else console.error("Could not find pending card:", pendingKey); } else disablePlayerSelectionMode(); return true; } else { console.warn("Invalid loaded state."); localStorage.removeItem(STORAGE_KEY_GAME); } } catch (e) { console.error("Error parsing state:", e); localStorage.removeItem(STORAGE_KEY_GAME); } } updateUIbasedOnGameState(); updateUndoButtonState(); return false; }
        function updateUIbasedOnGameState() { const pSE = document.getElementById('player-setup'); if (!scorePanelElement || !boardElement || !startGameBtnElement || !resetScoresBtnElement || !newGameBtnElement || !showFinalJeopardyBtnElement || !victoryElement) { console.error("UI elements missing."); return; } if (gameStarted) { if (pSE) pSE.style.display = 'none'; scorePanelElement.style.display = 'flex'; generateBoard(); updatePlayerCards(); updateScoreDisplay(); startGameBtnElement.disabled = true; resetScoresBtnElement.disabled = false; newGameBtnElement.disabled = false; if (answeredCluesCount >= totalClues && finalJeopardySectionElement.style.display !== 'block') { showVictory(false); showFinalJeopardyBtnElement.disabled = false; } else if (finalJeopardySectionElement.style.display !== 'block'){ victoryElement.style.display = 'none'; showFinalJeopardyBtnElement.disabled = true; if (!Object.values(boardState).some(s => s?.isDailyDouble) && answeredCluesCount < totalClues) { console.log("Determining DD on load."); determineDailyDouble(); } } else { victoryElement.style.display = 'none'; } } else { if (pSE) pSE.style.display = 'flex'; scorePanelElement.style.display = 'none'; boardElement.style.display = 'none'; updatePlayerCards(); updateScoreDisplay(); startGameBtnElement.disabled = players.length === 0; resetScoresBtnElement.disabled = true; if (undoBtnElement) undoBtnElement.disabled = true; showFinalJeopardyBtnElement.disabled = true; victoryElement.style.display = 'none'; finalJeopardySectionElement.style.display = 'none'; if(musicElement) musicElement.pause(); disablePlayerSelectionMode(); } drawScoreHistoryChart(); }
        function showVictory(launchConfettiEffect = true) { if(victoryElement) victoryElement.style.display = 'block'; if(showFinalJeopardyBtnElement) showFinalJeopardyBtnElement.disabled = false; if (launchConfettiEffect) launchConfetti(); if(boardElement) boardElement.style.display = 'none'; }
        function launchConfetti() { const cC=100; const cCo=document.body; for (let i = 0; i < cC; i++) { const c = document.createElement('div'); c.className = 'confetti'; c.style.left = Math.random() * 100 + 'vw'; c.style.backgroundColor = PLAYER_COLORS[Math.floor(Math.random() * PLAYER_COLORS.length)]; const aD = Math.random() * 3 + 2; c.style.animationDuration = aD + 's'; c.style.animationDelay = Math.random() * 0.5 + 's'; cCo.appendChild(c); setTimeout(() => { c.remove(); }, (aD + 1) * 1000); } }
        function playSound(audioElement) { if (audioElement && typeof audioElement.play === 'function' && musicToggleElement?.checked) { audioElement.currentTime = 0; audioElement.play().catch(e => console.warn("Audio fail:", audioElement.id, e.message)); } else if (!musicToggleElement?.checked && audioElement !== musicElement) {} else if (!audioElement) console.warn("Null audio element."); }
        function setupFinalJeopardy() { if (finalJeopardyQuestions.length === 0) { alert("No FJ questions!"); return; } const eP = players.filter(p => p.score > 0); if (eP.length === 0) { alert("No eligible players for FJ!"); showFinalResults(); return; } finalJeopardyData = finalJeopardyQuestions[Math.floor(Math.random() * finalJeopardyQuestions.length)]; if (!finalCategoryElement || !finalQuestionElement || !revealFinalQuestionBtnElement || !submitFinalWagersBtnElement || !judgeFinalAnswersBtnElement || !finalWagersContainerElement || !finalJeopardySectionElement ) { console.error("FJ UI missing."); return; } disablePlayerSelectionMode(); activeCardElement = null; finalCategoryElement.textContent = `Category: ${finalJeopardyData.category}`; finalQuestionElement.textContent = finalJeopardyData.question; finalQuestionElement.style.display = 'none'; revealFinalQuestionBtnElement.style.display = 'inline-block'; submitFinalWagersBtnElement.style.display = 'none'; judgeFinalAnswersBtnElement.style.display = 'none'; finalWagersContainerElement.innerHTML = ''; eP.forEach(p => { const r = document.createElement('div'); r.className = 'wager-row'; const l = document.createElement('label'); l.htmlFor = `wager-${p.id}`; l.textContent = `${p.name} ($${p.score}):`; const i = document.createElement('input'); i.type = 'number'; i.id = `wager-${p.id}`; i.dataset.playerId = p.id; i.min = 0; i.max = p.score; i.placeholder = 'Enter wager'; i.required = true; r.appendChild(l); r.appendChild(i); finalWagersContainerElement.appendChild(r); }); finalJeopardySectionElement.style.display = 'block'; if(boardElement) boardElement.style.display = 'none'; if(scorePanelElement) scorePanelElement.style.display = 'none'; if(victoryElement) victoryElement.style.display = 'none'; playSound(finalJeopardySound); saveGameProgress(); }
        function renderHighScores() { if (!highScoresListElement) return; try { const sS = JSON.parse(localStorage.getItem(STORAGE_KEY_SCORES) || '[]'); const sortS = sS.sort((a, b) => b.score - a.score).slice(0, 10); if (sortS.length === 0) highScoresListElement.innerHTML = '<li>No scores.</li>'; else highScoresListElement.innerHTML = sortS.map((s, i) => `<li><span>${i + 1}. ${s.name} (${new Date(s.date || Date.now()).toLocaleDateString()})</span><span>$${s.score}</span></li>`).join(''); } catch (e) { console.error("Err loading scores:", e); highScoresListElement.innerHTML = '<li>Error.</li>'; } }
        function saveScoresToHighScores() { const sTS = players.map(p => ({ name: p.name, score: p.score, date: Date.now() })); if (sTS.length === 0) return; try { const eS = JSON.parse(localStorage.getItem(STORAGE_KEY_SCORES) || '[]'); const uS = [...eS, ...sTS]; localStorage.setItem(STORAGE_KEY_SCORES, JSON.stringify(uS)); renderHighScores(); alert("Scores saved!"); if (resultsModalElement) resultsModalElement.classList.remove('show'); const hSTB = document.querySelector('.tab-button[data-tab="high-scores-tab"]'); if(hSTB) hSTB.click(); } catch (e) { console.error("Err saving scores:", e); alert("Failed."); } }
        function setupTabs() { const tB = document.querySelectorAll('.tab-button'); const tC = document.querySelectorAll('.tab-content'); tB.forEach(b => { b.addEventListener('click', () => { const tId = b.dataset.tab; if (!tId) return; tB.forEach(btn => btn.classList.remove('active')); tC.forEach(c => c.classList.remove('active')); b.classList.add('active'); const aC = document.getElementById(tId); if (aC) { aC.classList.add('active'); if (tId === 'score-history-tab') drawScoreHistoryChart(); else if (tId === 'high-scores-tab') renderHighScores(); } else console.warn("Tab content missing:", tId); }); }); const iAB = document.querySelector('.tab-button.active'); if (iAB) { const iId = iAB.dataset.tab; const iC = document.getElementById(iId); if(iC) iC.classList.add('active'); if (iId === 'score-history-tab') drawScoreHistoryChart(); else if (iId === 'high-scores-tab') renderHighScores(); } else if (tB.length > 0) tB[0].click(); }
        function drawScoreHistoryChart() { if (!scoreHistoryChartCanvas || !chartPlaceholderText) return; const ctx = scoreHistoryChartCanvas.getContext('2d'); if (!ctx) return; if (activeChart) { activeChart.destroy(); activeChart = null; } const datasets = players.filter(p => scoreHistory[p.id] && scoreHistory[p.id].length > 0).map(p => { const h = scoreHistory[p.id] || []; const fH = [...h].sort((a, b) => a.turn - b.turn); if (fH.length === 0 || fH[0].turn !== 0) fH.unshift({ turn: 0, score: 0 }); const uTH = []; const tS = new Set(); for (let i = fH.length - 1; i >= 0; i--) { const e = fH[i]; if (!tS.has(e.turn)) { uTH.unshift(e); tS.add(e.turn); } } return { label: p.name, data: uTH.map(e => ({ x: e.turn, y: e.score })), borderColor: p.color, backgroundColor: p.color + '30', fill: false, tension: 0.1 }; }); if (datasets.length > 0) { chartPlaceholderText.style.display = 'none'; scoreHistoryChartCanvas.style.display = 'block'; activeChart = new Chart(ctx, { type: 'line', data: { datasets }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'linear', title: { display: true, text: 'Action Turn Number' }, beginAtZero: true, ticks: { stepSize: 1, precision: 0 } }, y: { title: { display: true, text: 'Score ($)' }, beginAtZero: true } }, plugins: { title: { display: true, text: 'Score Progression Over Turns'}, tooltip: { mode: 'index', intersect: false } }, interaction: { mode: 'nearest', axis: 'x', intersect: false } } }); } else { chartPlaceholderText.style.display = 'block'; scoreHistoryChartCanvas.style.display = 'none'; } }
        function updateUndoButtonState() { if (undoBtnElement) undoBtnElement.disabled = historyStack.length === 0; }
        function showFinalResults() { if (!finalResultsElement || !resultsModalElement) return; const sP = [...players].sort((a, b) => b.score - a.score); finalResultsElement.innerHTML = sP.map(p => `<div>${p.name}: $${p.score}</div>`).join(''); resultsModalElement.classList.add('show'); }

        // --- Event Listeners Setup ---
        function setupEventListeners() {
            if(addPlayerBtnElement) addPlayerBtnElement.addEventListener('click', () => { if (!playerNameInputElement) return; const name = playerNameInputElement.value.trim(); if (!name) { alert("Enter name."); return; } if (players.length >= PLAYER_COLORS.length) { alert("Max players."); return; } const id = Date.now().toString(36) + Math.random().toString(36).substring(2); players.push({ id, name, score: 0, color: PLAYER_COLORS[players.length % PLAYER_COLORS.length] }); playerNameInputElement.value = ''; updatePlayerCards(); if(startGameBtnElement) startGameBtnElement.disabled = false; playerNameInputElement.focus(); });
            if(startGameBtnElement) startGameBtnElement.addEventListener('click', () => { if (players.length === 0) { alert("Add player!"); return; } gameStarted = true; playerTurnIndex = 0; currentPlayerId = players[playerTurnIndex]?.id; answeredCluesCount = 0; boardState = {}; historyStack = []; scoreHistory = {}; players.forEach(p => { p.score = 0; scoreHistory[p.id] = [{ turn: 0, score: 0 }]; }); turnCounter = 0; determineDailyDouble(); updateUIbasedOnGameState(); updateUndoButtonState(); if (musicToggleElement?.checked && musicElement) { musicElement.currentTime = 0; playSound(musicElement); } saveGameProgress(); });
            if(applyScoreBtnElement) applyScoreBtnElement.addEventListener('click', () => { if (!currentPlayerId || !manualScoreInputElement) return; const targetScore = parseInt(manualScoreInputElement.value, 10); if (isNaN(targetScore)) { alert("Valid number needed."); return; } const player = getPlayerById(currentPlayerId); if (player) { const delta = targetScore - player.score; turnCounter++; updatePlayerScore(currentPlayerId, delta, false, 'manual_update'); manualScoreInputElement.value = ''; } });
            if(undoBtnElement) undoBtnElement.addEventListener('click', () => { const lastAction = historyStack.pop(); updateUndoButtonState(); if (!lastAction) return; console.log("Undo:", lastAction); if (lastAction.action === 'score') { const player = getPlayerById(lastAction.playerId); if (player) { player.score -= lastAction.delta; if (scoreHistory[lastAction.playerId]) { const scoreAfter = player.score + lastAction.delta; const lastIdx = scoreHistory[lastAction.playerId].findLastIndex(e => e.turn === lastAction.turn && e.score === scoreAfter); if (lastIdx > -1) scoreHistory[lastAction.playerId].splice(lastIdx, 1); else console.warn(`Undo: No history match P:${lastAction.playerId} T:${lastAction.turn}`); } console.log(`Undo Score: ${player.name} to ${player.score}`); } if (lastAction.cardKey && boardState[lastAction.cardKey] && lastAction.cardKey !== 'manual_update' && lastAction.cardKey !== 'final_jeopardy') { const cardEl = document.querySelector(`.card[data-state-key="${lastAction.cardKey}"]`); const cardState = boardState[lastAction.cardKey]; const wasCorrect = cardState.state === 'correct' && cardState.playerId === lastAction.playerId; const wasWrongFinal = cardState.state === 'wrong'; const wasFailed = lastAction.delta < 0 && !cardState.state && cardState.failedPlayerIds?.includes(lastAction.playerId); console.log(`Undo Card: ${lastAction.cardKey}, Correct:${wasCorrect}, WrongF:${wasWrongFinal}, Failed:${wasFailed}`); if (wasCorrect || wasWrongFinal) { answeredCluesCount--; cardState.state = null; cardState.playerId = null; } if (wasFailed || wasCorrect || wasWrongFinal) { if (cardState.failedPlayerIds) { const fIdx = cardState.failedPlayerIds.indexOf(lastAction.playerId); if (fIdx > -1) { cardState.failedPlayerIds.splice(fIdx, 1); console.log(`Undo: Removed ${player?.name} from failed list`); } } } if (cardEl) { cardEl.classList.remove('disabled', 'correct', 'wrong', 'pending-steal'); const fF = cardEl.querySelector('.card-front'); if (fF && (wasCorrect || wasWrongFinal)) { fF.textContent = `$${cardEl.dataset.value}`; fF.classList.remove('empty-value'); } cardEl.removeEventListener('click', handleCardClick); cardEl.addEventListener('click', handleCardClick); const jB = cardEl.querySelector('.judge-buttons'); if (jB && (wasFailed || cardState.failedPlayerIds?.length > 0)) { jB.style.display = 'flex'; console.log(`Undo: Made card active.`); } if (cardState.failedPlayerIds?.length > 0 && !cardState.state) { activeCardElement = cardEl; enablePlayerSelectionMode(); } else { disablePlayerSelectionMode(); } } console.log(`Undo: Reverted card ${lastAction.cardKey}`); } updatePlayerCards(); updateScoreDisplay(); drawScoreHistoryChart(); saveGameProgress(); } else if (lastAction) { historyStack.push(lastAction); updateUndoButtonState(); console.warn("Undo not implemented:", lastAction.action); } });
            if(resetScoresBtnElement) resetScoresBtnElement.addEventListener('click', () => { if (confirm("Reset scores?")) { historyStack = []; scoreHistory = {}; players.forEach(p => { p.score = 0; scoreHistory[p.id] = [{ turn: 0, score: 0 }]; }); turnCounter = 0; updatePlayerCards(); updateScoreDisplay(); updateUndoButtonState(); drawScoreHistoryChart(); saveGameProgress(); alert("Scores reset."); } });
            if(newGameBtnElement) newGameBtnElement.addEventListener('click', () => { if (confirm("Start new game?")) { localStorage.removeItem(STORAGE_KEY_GAME); players = []; currentPlayerId = null; gameStarted = false; boardState = {}; historyStack = []; scoreHistory = {}; answeredCluesCount = 0; currentWager = 0; turnCounter = 0; playerTurnIndex = 0; activeCardElement = null; if (activeChart) { activeChart.destroy(); activeChart = null; } const pSE = document.getElementById('player-setup'); if (pSE) pSE.style.display = 'flex'; if (playerListElement) playerListElement.innerHTML = ''; if (scorePanelElement) scorePanelElement.style.display = 'none'; if (boardElement) { boardElement.style.display = 'none'; boardElement.innerHTML = ''; } if (finalJeopardySectionElement) finalJeopardySectionElement.style.display = 'none'; if (victoryElement) victoryElement.style.display = 'none'; if (resultsModalElement) resultsModalElement.classList.remove('show'); if (playerNameInputElement) playerNameInputElement.value = ''; if (startGameBtnElement) startGameBtnElement.disabled = true; if (showFinalJeopardyBtnElement) showFinalJeopardyBtnElement.disabled = true; if (resetScoresBtnElement) resetScoresBtnElement.disabled = true; if (undoBtnElement) undoBtnElement.disabled = true; if(musicElement) { musicElement.pause(); musicElement.currentTime = 0; } disablePlayerSelectionMode(); updateScoreDisplay(); updateUndoButtonState(); const gTB = document.querySelector('.tab-button[data-tab="game-tab"]'); if(gTB) gTB.click(); alert("New game. Add players."); } });
            if(musicToggleElement) musicToggleElement.addEventListener('change', () => { if (musicToggleElement.checked && gameStarted && musicElement) { if (musicElement.paused) { playSound(musicElement); } } else if(musicElement) { musicElement.pause(); } });
            if(showFinalJeopardyBtnElement) showFinalJeopardyBtnElement.addEventListener('click', setupFinalJeopardy);
            if(revealFinalQuestionBtnElement) revealFinalQuestionBtnElement.addEventListener('click', () => { if (finalQuestionElement) finalQuestionElement.style.display = 'block'; revealFinalQuestionBtnElement.style.display = 'none'; if (submitFinalWagersBtnElement) { submitFinalWagersBtnElement.style.display = 'inline-block'; submitFinalWagersBtnElement.disabled = false; } const fWI = finalWagersContainerElement?.querySelector('input[type="number"]'); if(fWI) fWI.focus(); });
            if(submitFinalWagersBtnElement) submitFinalWagersBtnElement.addEventListener('click', () => { let allV=true; finalWagersContainerElement?.querySelectorAll('.wager-row input[type="number"]').forEach(i => { const w=parseInt(i.value, 10); const m=parseInt(i.max, 10); if (isNaN(w) || w < 0 || w > m) { allV=false; i.style.border='2px solid red'; } else { i.style.border=''; i.disabled=true; } }); if (!allV) { alert("Correct invalid wagers."); finalWagersContainerElement?.querySelectorAll('.wager-row input[type="number"]').forEach(i => { if (i.style.border.includes('red')) i.disabled=false; }); return; } submitFinalWagersBtnElement.disabled = true; if (judgeFinalAnswersBtnElement) judgeFinalAnswersBtnElement.style.display = 'inline-block'; alert("Wagers locked."); });
            if(judgeFinalAnswersBtnElement) judgeFinalAnswersBtnElement.addEventListener('click', () => { finalWagersContainerElement?.querySelectorAll('.wager-row input[type="number"]').forEach(i => { const pId=i.dataset.playerId; const w=parseInt(i.value, 10); const p=getPlayerById(pId); if (p && !isNaN(w)) { const isC=confirm(`Did ${p.name} answer correctly?`); const d=isC?w:-w; turnCounter++; updatePlayerScore(pId, d, false, 'final_jeopardy'); } }); if (finalJeopardySectionElement) finalJeopardySectionElement.style.display = 'none'; if (judgeFinalAnswersBtnElement) judgeFinalAnswersBtnElement.style.display = 'none'; showFinalResults(); launchConfetti(); saveGameProgress(); });
            if(modalCloseElement) modalCloseElement.addEventListener('click', () => { if(resultsModalElement) resultsModalElement.classList.remove('show'); });
            if(saveHighScoresBtnElement) saveHighScoresBtnElement.addEventListener('click', saveScoresToHighScores);
        }

        // --- Initialization ---
        function initializeGame() {
            console.log("Initializing Jeopardy Game v6 (Host Intervention)...");
            setupTabs(); setupEventListeners(); loadGameProgress(); renderHighScores(); updateUndoButtonState();
        }

        // --- Start ---
        document.addEventListener('DOMContentLoaded', initializeGame);

    </script>

</body>
</html>
